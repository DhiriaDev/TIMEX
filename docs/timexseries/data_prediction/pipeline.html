<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>timexseries.data_prediction.pipeline API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>timexseries.data_prediction.pipeline</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import os
import pickle
from functools import reduce
from typing import Tuple

import dateparser
from pandas import DataFrame

from timexseries.data_ingestion import ingest_additional_regressors
from timexseries.data_prediction import PredictionModel
from timexseries.data_prediction.models.arima_predictor import ARIMAModel
from timexseries.data_prediction.models.exponentialsmoothing_predictor import ExponentialSmoothingModel
from timexseries.data_prediction.models.lstm_predictor import LSTMModel
from timexseries.data_prediction.models.mockup_predictor import MockUpModel
# from timexseries.data_prediction.models.neuralprophet_predictor import NeuralProphetModel
from timexseries.data_prediction.models.prophet_predictor import FBProphetModel
from timexseries.data_prediction.xcorr import calc_all_xcorr
from timexseries.timeseries_container import TimeSeriesContainer

log = logging.getLogger(__name__)


def prepare_extra_regressor(container: TimeSeriesContainer, model: str) -&gt; DataFrame:
    &#34;&#34;&#34;
    This function receives a `timexseries.timeseries_container.TimeSeriesContainer` object, which includes the time-series
    historical data and the various predictions for the future.

    The best prediction for the model &#39;model&#39; is taken and appended to the original time-series, in order to obtain a
    DataFrame with the original time series and the best possible prediction.

    The resulting DataFrame is returned.

    Parameters
    ----------
    container : TimeSeriesContainer
        `timexseries.timeseries_container.TimeSeriesContainer` from which an extra-regressor should be extracted.

    model
        The model from which get the best available prediction.

    Returns
    -------
    df : DataFrame
        DataFrame with the length of the original time-series + prediction lags.
    &#34;&#34;&#34;
    name = container.timeseries_data.columns[0]
    best_prediction = container.models[model].best_prediction

    original_ts = container.timeseries_data
    f = best_prediction.loc[:, [&#39;yhat&#39;]]
    f.rename(columns={&#39;yhat&#39;: name}, inplace=True)

    best_entire_forecast = original_ts.combine_first(f)

    return best_entire_forecast


def get_best_univariate_predictions(ingested_data: DataFrame, param_config: dict, total_xcorr: dict = None) -&gt; \
        Tuple[dict, list]:
    &#34;&#34;&#34;
    Compute, for every column in `ingested_data` (every time-series) the best univariate prediction possible.
    This is done using the models specified in `param_config` and testing the effect of the different transformations
    specified in `param_config`. Moreover, the best feature transformation found, across the possible ones, will be
    returned.

    Parameters
    ----------
    ingested_data : DataFrame
        Initial data of the time-series.
    param_config : dict
        TIMEX configuration dictionary. In particular, the `model_parameters` sub-dictionary will be used. In
        `model_parameters` the following options has to be specified:

        - `possible_transformations`: comma-separated list of transformations keywords (e.g. &#34;none,log_modified&#34;).
        - `main_accuracy_estimator`: error metric which will be minimized as target by the procedure. E.g. &#34;mae&#34;.
        - `models`: comma-separated list of the models to use (e.g. &#34;fbprophet,arima&#34;).

    total_xcorr : dict, optional, default None
        Cross-correlation dictionary computed by `calc_all_xcorr`. The cross-correlation is actually not used in this
        function, however it is used to build the returned `timexseries.timeseries_container.TimeSeriesContainer`, if given.

    Returns
    -------
    dict
        Dictionary which assigns the best transformation for every used prediction model, for every time-series.
    list
        A list of `timexseries.timeseries_container.TimeSeriesContainer` objects, one for each time-series.

    Examples
    --------
    Create some fake data:
    &gt;&gt;&gt; dates = pd.date_range(&#39;2000-01-01&#39;, periods=30)  # Last index is 2000-01-30
    &gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&#34;D&#34;)
    &gt;&gt;&gt; a = np.arange(30, 60)
    &gt;&gt;&gt; b = np.arange(60, 90)
    &gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&#34;a&#34;: a, &#34;b&#34;: b}, index=ds)

    And create the model configuration part of the TIMEX configuration dictionary:
    &gt;&gt;&gt; param_config = {
    ...   &#34;model_parameters&#34;: {
    ...     &#34;models&#34;: &#34;fbprophet&#34;,  # Model(s) which will be tested.
    ...     &#34;possible_transformations&#34;: &#34;none,log_modified&#34;,  # Possible feature transformation to test.
    ...     &#34;main_accuracy_estimator&#34;: &#34;mae&#34;,
    ...     &#34;delta_training_percentage&#34;: 20,  # Training windows will be incremented by the 20% each step...
    ...     &#34;test_values&#34;: 5,  # Use the last 5 values as validation set.
    ...     &#34;prediction_lags&#34;: 7,  # Predict the next 7 points after 2000-01-30.
    ...     }
    ... }

    Now, get the univariate predictions:
    &gt;&gt;&gt; best_transformations, timeseries_outputs = get_best_univariate_predictions(timeseries_dataframe, param_config)

    Let&#39;s inspect the results. `best_transformations` contains the suggested feature transformations to use:
    &gt;&gt;&gt; best_transformations
    {&#39;fbprophet&#39;: {&#39;a&#39;: &#39;none&#39;, &#39;b&#39;: &#39;none&#39;}}

    It is reasonable with this simple data that no transformation is the best transformation.
    We have the `timexseries.timeseries_container.TimeSeriesContainer` list as well:
    &gt;&gt;&gt; timeseries_outputs
    [&lt;timexseries.timeseries_container.TimeSeriesContainer at 0x7f62f45d1fa0&gt;,
     &lt;timexseries.timeseries_container.TimeSeriesContainer at 0x7f62d4e97cd0&gt;]

    These are the `timexseries.timeseries_container.TimeSeriesContainer` objects, one for time-series `a` and one for `b`.
    Each one has various fields, in this case the most interesting one is `models`:
    &gt;&gt;&gt; timeseries_outputs[0].models
    {&#39;fbprophet&#39;: &lt;timexseries.data_prediction.models.predictor.ModelResult at 0x7f62f45d1d90&gt;}

    This is the `timexseries.data_prediction.models.predictor.ModelResult` object for FBProphet that we have just computed.
    &#34;&#34;&#34;
    transformations_to_test = [*param_config[&#34;model_parameters&#34;][&#34;possible_transformations&#34;].split(&#34;,&#34;)]
    main_accuracy_estimator = param_config[&#34;model_parameters&#34;][&#34;main_accuracy_estimator&#34;]
    models = [*param_config[&#34;model_parameters&#34;][&#34;models&#34;].split(&#34;,&#34;)]

    best_transformations = dict.fromkeys(models, {})
    timeseries_containers = []

    try:
        max_threads = param_config[&#39;max_threads&#39;]
    except KeyError:
        try:
            max_threads = len(os.sched_getaffinity(0))
        except:
            max_threads = 1

    columns = ingested_data.columns

    for col in columns:
        model_results = {}
        timeseries_data = ingested_data[[col]]
        xcorr = total_xcorr[col] if total_xcorr is not None else None

        for model in models:
            this_model_performances = []

            log.info(f&#34;Using model {model}...&#34;)

            for transf in transformations_to_test:
                log.info(f&#34;Computing univariate prediction for {col} using transformation: {transf}...&#34;)
                predictor = model_factory(model, param_config=param_config, transformation=transf)
                _result = predictor.launch_model(timeseries_data.copy(), max_threads=max_threads)

                performances = _result.results
                performances.sort(key=lambda x: getattr(x.testing_performances, main_accuracy_estimator.upper()))
                performances = getattr(performances[0].testing_performances, main_accuracy_estimator.upper())

                this_model_performances.append((_result, performances, transf))

            this_model_performances.sort(key=lambda x: x[1])
            best_tr = this_model_performances[0][2]
            [log.debug(f&#34;Error with {t}: {e}&#34;) for t, e in zip(map(lambda x: x[2], this_model_performances),
                                                               map(lambda x: x[1], this_model_performances))]
            log.info(f&#34;Best transformation for {col} using {model}: {best_tr}&#34;)
            best_transformations[model][col] = best_tr
            model_results[model] = this_model_performances[0][0]

        timeseries_containers.append(
            TimeSeriesContainer(timeseries_data, model_results, xcorr)
        )

    return best_transformations, timeseries_containers


def get_best_multivariate_predictions(timeseries_containers: [TimeSeriesContainer], ingested_data: DataFrame,
                                      best_transformations: dict, total_xcorr: dict, param_config: dict):
    &#34;&#34;&#34;
    Starting from the a list of `timexseries.timeseries_container.TimeSeriesContainer`, use the available univariated
    predictions and the time-series in `ingested_data`, plus eventual user-given additional regressors to compute new
    multivariate predictions.

    These new predictions will be used only if better than the univariate ones.

    Returns the updated list of `timexseries.timeseries_container.TimeSeriesContainer`.

    Parameters
    ----------
    timeseries_containers : [TimeSeriesContainer]
        Initial `timexseries.timeseries_container.TimeSeriesContainer` list from which the computation of multivariate
        predictions start. Some univariate predictions should be already present in each object: more formally, each
        `timexseries.timeseries_container.TimeSeriesContainer` should have the `model_results` attribute.
    ingested_data : DataFrame
        Initial data of the time-series.
    best_transformations : dict
        Dictionary which assigns the best transformation for every used prediction model, for every time-series. It
        should be returned by `get_best_univariate_predictions`.
    total_xcorr : dict
        Cross-correlation dictionary computed by `timexseries.data_prediction.xcorr.calc_all_xcorr`. The cross-correlation is
        used in this function, to find, among all the time-series in `ingested_data`, additional regressors for each
        time-series, if there are some.
    param_config : dict
        TIMEX configuration dictionary. In particular, the `xcorr_parameters` sub-dictionary will be used. In
        `xcorr_parameters` the following options has to be specified if `total_xcorr` parameter is not None:

        - `xcorr_mode_target`: which cross-correlation algorithm should be used as target in evaluating useful
          additional regressors. E.g. &#34;pearson&#34;.
        - `xcorr_extra_regressor_threshold`: the minimum absolute value of cross-correlation which indicates a useful
          extra-regressor. E.g. 0.8.

        Additionally, the `additional_regressors` part of the TIMEX configuration parameter dictionary can be used by
        the user to specify additional CSV paths to time-series data to use as extra-regressor.
        It should be a dictionary in the form &#34;target time-series&#34;: &#34;path of the additional extra-regressors&#34;.
        The key &#34;_all&#34; is a special key which indicates a path to additional extra-regressors which will be used for
        any time-series.

    Returns
    -------
    list
        A list of `timexseries.timeseries_container.TimeSeriesContainer` objects, one for each time-series.

    Examples
    --------
    We will create ad-hoc time-series in which using a multivariate model will perform better than using a univariate
    one.

    &gt;&gt;&gt; dates = pd.date_range(&#39;2000-01-01&#39;, periods=30)  # Last index is 2000-01-30
    &gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&#34;D&#34;)
    &gt;&gt;&gt;
    &gt;&gt;&gt; x = np.linspace(0, 2 * np.pi, 60)
    &gt;&gt;&gt; y = np.sin(x)
    &gt;&gt;&gt;
    &gt;&gt;&gt; np.random.seed(0)
    &gt;&gt;&gt; noise = np.random.normal(0, 2.0, 60)
    &gt;&gt;&gt; y = y + noise
    &gt;&gt;&gt;
    &gt;&gt;&gt; a = y[:30]
    &gt;&gt;&gt; b = y[5:35]
    &gt;&gt;&gt;
    &gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&#34;a&#34;: a, &#34;b&#34;: b}, index=ds)

    In this dataset the time-series `b` can be used to better predict `a`... simply because it is the same series, but
    traslated!

    Try to perform the computations.

    &gt;&gt;&gt; param_config = {
    ...     &#34;model_parameters&#34;: {
    ...         &#34;models&#34;: &#34;LSTM&#34;,
    ...         &#34;possible_transformations&#34;: &#34;none,log_modified&#34;,
    ...         &#34;main_accuracy_estimator&#34;: &#34;mae&#34;,
    ...         &#34;delta_training_percentage&#34;: 20,
    ...         &#34;test_values&#34;: 5,
    ...         &#34;prediction_lags&#34;: 7,
    ...     },
    ...     &#34;xcorr_parameters&#34;: {
    ...         &#34;xcorr_mode_target&#34;: &#34;pearson&#34;,
    ...         &#34;xcorr_extra_regressor_threshold&#34;: 0.7,
    ...         &#34;xcorr_max_lags&#34;: 6,
    ...         &#34;xcorr_mode&#34;: &#34;pearson&#34;
    ...     }
    ... }
    &gt;&gt;&gt; xcorr = calc_all_xcorr(timeseries_dataframe, param_config)
    &gt;&gt;&gt; best_transformations, timeseries_outputs = get_best_univariate_predictions(timeseries_dataframe, param_config)
    &gt;&gt;&gt; timeseries_outputs = get_best_multivariate_predictions(timeseries_outputs, timeseries_dataframe,
    &gt;&gt;&gt;                                                        best_transformations, xcorr, param_config)

    From the log, we can see:
    &gt;&gt;&gt; &#34;INFO:timexseries.data_prediction.pipeline:Found useful extra-regressors: Index([&#39;b&#39;], dtype=&#39;object&#39;). Re-compute the prediction for a&#34;
    &gt;&gt;&gt; &#34;INFO:timexseries.data_prediction.models.predictor:Creating a LSTM model...&#34;
    &gt;&gt;&gt; &#34;INFO:timexseries.data_prediction.models.predictor:Model will use 5 different training sets...&#34;
    &gt;&gt;&gt; &#34;INFO:timexseries.data_prediction.models.predictor:LSTM/NeuralProphet model. Cant use multiprocessing.&#34;
    &gt;&gt;&gt; &#34;INFO:timexseries.data_prediction.pipeline:Obtained a better error: 1.6009327718008979 vs old 1.9918351002921089&#34;

    This means that using `b` as additional regressor for `a` made us obtain a better error.
    &#34;&#34;&#34;
    iterations = 0
    best_forecasts_found = 0

    if total_xcorr is not None:
        xcorr_mode_target = param_config[&#34;xcorr_parameters&#34;][&#34;xcorr_mode_target&#34;]
        xcorr_threshold = param_config[&#34;xcorr_parameters&#34;][&#34;xcorr_extra_regressor_threshold&#34;]

    try:
        additional_regressors = param_config[&#34;additional_regressors&#34;]
    except KeyError:
        additional_regressors = None

    models = [*param_config[&#34;model_parameters&#34;][&#34;models&#34;].split(&#34;,&#34;)]

    try:
        max_threads = param_config[&#39;max_threads&#39;]
    except KeyError:
        try:
            max_threads = len(os.sched_getaffinity(0))
        except:
            max_threads = 1

    for model in models:
        log.info(f&#34;Checking optimal predictions with model {model}&#34;)
        best_forecasts_found = 0
        iterations = 0

        while best_forecasts_found != len(ingested_data.columns):
            log.info(f&#34;-&gt; Found the optimal prediction for only {best_forecasts_found}&#34;)
            best_forecasts_found = 0

            for col in ingested_data.columns:
                depends_on_other_ts = False
                useful_extra_regressors = []

                log.debug(f&#34;Look for extra regressors in other dataset&#39;s columns...&#34;)
                try:
                    local_xcorr = total_xcorr[col][xcorr_mode_target]

                    # Add extra regressors from the original dataset
                    for extra_regressor in local_xcorr.columns:
                        # Look only in correlation with future lags.
                        index_of_max = local_xcorr[extra_regressor].abs().idxmax()
                        corr = local_xcorr.loc[index_of_max, extra_regressor]
                        if abs(corr) &gt; xcorr_threshold and index_of_max &gt;= 0:
                            log.debug(
                                f&#34;Found a possible extra-regressor for {col}: {extra_regressor} at lag {index_of_max}&#34;)

                            useful_extra_regressors.append(
                                prepare_extra_regressor(next(filter(
                                    lambda x: x.timeseries_data.columns[0] == extra_regressor, timeseries_containers)), model=model))
                            depends_on_other_ts = True
                    local_xcorr = total_xcorr[col]  # To give the full xcorr to Scenario
                except:
                    local_xcorr = None

                log.debug(f&#34;Look for user-given additional regressors...&#34;)
                try:
                    additional_regressor_path = additional_regressors[&#34;_all&#34;]
                    useful_extra_regressors.append(ingest_additional_regressors(additional_regressor_path, param_config))
                except:
                    pass

                try:
                    additional_regressor_path = additional_regressors[col]
                    useful_extra_regressors.append(ingest_additional_regressors(additional_regressor_path, param_config))
                except:
                    pass

                if len(useful_extra_regressors) == 0:
                    log.debug(f&#34;No useful extra-regressor found for {col}: skipping...&#34;)
                    best_forecasts_found += 1
                else:
                    useful_extra_regressors = reduce(lambda x, y: x.join(y), useful_extra_regressors)
                    log.info(f&#34;Found useful extra-regressors: {useful_extra_regressors.columns}. &#34;
                             f&#34;Re-compute the prediction for {col}&#34;)

                    timeseries_data = ingested_data[[col]]

                    tr = best_transformations[model][col]

                    predictor = model_factory(model, param_config, transformation=tr)
                    _result = predictor.launch_model(timeseries_data.copy(),
                                                     extra_regressors=useful_extra_regressors.copy(),
                                                     max_threads=max_threads)
                    old_this_container = next(filter(lambda x: x.timeseries_data.columns[0] == col, timeseries_containers))

                    old_errors = [x.testing_performances.MAE for x in old_this_container.models[model].results]
                    min_old_error = min(old_errors)
                    min_new_error = min([x.testing_performances.MAE for x in _result.results])

                    if min_new_error &lt; min_old_error:
                        log.info(f&#34;Obtained a better error: {min_new_error} vs old {min_old_error}&#34;)
                        new_model_results = old_this_container.models
                        new_model_results[model] = _result
                        new_container = TimeSeriesContainer(timeseries_data, new_model_results, local_xcorr)
                        timeseries_containers = [new_container if x.timeseries_data.columns[0] == col else x for x in timeseries_containers]
                        if not depends_on_other_ts:
                            best_forecasts_found += 1
                    else:
                        log.info(f&#34;No improvements.&#34;)
                        best_forecasts_found += 1
            iterations += 1

    log.info(f&#34;Found the optimal prediction for all the {best_forecasts_found} time-series in {iterations} iterations!&#34;)
    return timeseries_containers


def get_best_predictions(ingested_data: DataFrame, param_config: dict):
    &#34;&#34;&#34;
    Starting from `ingested_data`, using the models/cross correlation settings set in `param_config`, return the best
    possible predictions in a `timexseries.timeseries_container.TimeSeriesContainer` for each time-series in `ingested_data`.

    Parameters
    ----------
    ingested_data : DataFrame
        Initial data of the time-series.

    param_config : dict
        TIMEX configuration dictionary. `get_best_univariate_predictions` and `get_best_multivariate_predictions` will
        use the various settings in `param_config`.

    Returns
    -------
    list
        A list of `timexseries.timeseries_container.TimeSeriesContainer` objects, one for each time-series.

    Examples
    --------
    This is basically the function on top of `get_best_univariate_predictions` and `get_best_multivariate_predictions`:
    it will call first the univariate and then the multivariate if the cross-correlation section is present
    in `param_config`.

    Create some data:
    &gt;&gt;&gt; dates = pd.date_range(&#39;2000-01-01&#39;, periods=30)  # Last index is 2000-01-30
    &gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&#34;D&#34;)
    &gt;&gt;&gt; a = np.arange(30, 60)
    &gt;&gt;&gt; b = np.arange(60, 90)
    &gt;&gt;&gt;
    &gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&#34;a&#34;: a, &#34;b&#34;: b}, index=ds)

    Simply compute the predictions and get the returned `timexseries.timeseries_container.TimeSeriesContainer` objects:
    &gt;&gt;&gt; timeseries_outputs = get_best_predictions(timeseries_dataframe, param_config)
    &#34;&#34;&#34;
    if &#34;xcorr_parameters&#34; in param_config and len(ingested_data.columns) &gt; 1:
        log.info(f&#34;Computing the cross-correlation...&#34;)
        total_xcorr = calc_all_xcorr(ingested_data=ingested_data, param_config=param_config)
    else:
        total_xcorr = None

    best_transformations, timeseries_containers = get_best_univariate_predictions(ingested_data, param_config,
                                                                                  total_xcorr)

    if total_xcorr is not None or &#34;additional_regressors&#34; in param_config:
        timeseries_containers = get_best_multivariate_predictions(timeseries_containers=timeseries_containers, ingested_data=ingested_data,
                                                      best_transformations=best_transformations,
                                                      total_xcorr=total_xcorr,
                                                      param_config=param_config)

    return timeseries_containers


def compute_historical_predictions(ingested_data, param_config):
    &#34;&#34;&#34;
    Compute the historical predictions, i.e. the predictions for (part) of the history of the time-series.

    Parameters
    ----------
    ingested_data : DataFrame
        Initial data of the time-series.
    param_config : dict
        TIMEX configuration dictionary. In particular, the `historical_prediction_parameters` sub-dictionary will be
        used. In `historical_prediction_parameters` the following options has to be specified:

        - `initial_index`: the point from which the historical computations will be made;
        - `save_path`: the historical computations are saved on a file, serialized with pickle. This allows the re-use
        of these predictions if TIMEX is restarted in the future.

        Additionally, the parameter `delta` can be specified: this indicates how many data points should be predicted
        every run. The default is `1`; a number greater than `1` will reduce the accuracy of the predictions because
        multiple points are predicted with the same model, but it will speed up the computation.

        `input_parameters` will be used because the `initial_index` date will be parsed with the same format provided in
        `input_parameters`, if any. Otherwise the standard `yyyy-mm-dd` format will be used.

    Returns
    -------
    list
        A list of `timexseries.timeseries_container.TimeSeriesContainer` objects, one for each time-series. These containers
        have the `historical_prediction` attribute; the predictions in `model_results` are the more recent available
        ones.

    Notes
    -----
    Historical predictions are predictions computed on past points of the time-series, but using only the data available
    until that point.

    Consider a time-series with length `p`. Consider that we want to find the historical predictions starting from the
    middle of the time-series, i.e. from index `s=p/2`.

    To do that, we take the data available from the start of the time-series to `s`, compute the prediction for the
    instant `s + 1`, and then move forward.

    When all the data has been used, we have `s` predictions, but also the real data corresponding to that predictions;
    this allows the user to check error metrics and understand the real performances of a model, on data never seen.

    These metrics can give an idea of the future performance of the model.

    Examples
    --------
    Create some sample data.
    &gt;&gt;&gt; dates = pd.date_range(&#39;2000-01-01&#39;, periods=30)  # Last index is 2000-01-30
    &gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&#34;D&#34;)
    &gt;&gt;&gt; a = np.arange(30, 60)
    &gt;&gt;&gt; b = np.arange(60, 90)
    &gt;&gt;&gt;
    &gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&#34;a&#34;: a, &#34;b&#34;: b}, index=ds)

    Create the configuration parameters dictionary:
    &gt;&gt;&gt; param_config = {
    ...     &#34;input_parameters&#34;: {
    ...     },
    ...     &#34;model_parameters&#34;: {
    ...         &#34;models&#34;: &#34;fbprophet&#34;,
    ...         &#34;possible_transformations&#34;: &#34;none,log_modified&#34;,
    ...         &#34;main_accuracy_estimator&#34;: &#34;mae&#34;,
    ...         &#34;delta_training_percentage&#34;: 20,
    ...         &#34;test_values&#34;: 5,
    ...         &#34;prediction_lags&#34;: 7,
    ...     },
    ...     &#34;historical_prediction_parameters&#34;: {
    ...         &#34;initial_index&#34;: &#34;2000-01-25&#34;,
    ...         &#34;save_path&#34;: &#34;example.pkl&#34;
    ...     }
    ... }

    Launch the computation.
    &gt;&gt;&gt; timeseries_outputs = compute_historical_predictions(timeseries_dataframe, param_config)

    Similarly to `get_best_predictions`, we have a list of `timexseries.timeseries_container.TimeSeriesContainer` objects.
    However, these objects also have an historical prediction:
    &gt;&gt;&gt; timeseries_outputs[0].historical_prediction
    {&#39;fbprophet&#39;:                  a
                 2000-01-26       55
                 2000-01-27       56
                 2000-01-28  56.3552
                 2000-01-29  58.1709
                 2000-01-30  58.9167
    }

    If multiple models were specified, `historical_prediction` dictionary would have other entries.
    &#34;&#34;&#34;
    input_parameters = param_config[&#34;input_parameters&#34;]
    models = [*param_config[&#34;model_parameters&#34;][&#34;models&#34;].split(&#34;,&#34;)]
    save_path = param_config[&#34;historical_prediction_parameters&#34;][&#34;save_path&#34;]
    try:
        hist_pred_delta = param_config[&#34;historical_prediction_parameters&#34;][&#34;delta&#34;]
    except KeyError:
        hist_pred_delta = 1

    try:
        with open(save_path, &#39;rb&#39;) as file:
            historical_prediction = pickle.load(file)
        log.info(f&#34;Loaded historical prediction from file...&#34;)
        current_index = historical_prediction[models[0]].index[-1]
    except FileNotFoundError:
        log.info(f&#34;Historical prediction file not found: computing from the start...&#34;)
        starting_index = param_config[&#34;historical_prediction_parameters&#34;][&#34;initial_index&#34;]

        if &#34;dateparser_options&#34; in input_parameters:
            dateparser_options = input_parameters[&#34;dateparser_options&#34;]
            current_index = dateparser.parse(starting_index, **dateparser_options)
        else:
            current_index = dateparser.parse(starting_index)

        historical_prediction = {}
        for model in models:
            historical_prediction[model] = DataFrame(columns=ingested_data.columns)

    final_index = ingested_data.index[-1]
    log.info(f&#34;Starting index: {current_index}&#34;)
    log.info(f&#34;Final index: {final_index}&#34;)
    delta_time = 1 * ingested_data.index.freq

    if current_index == final_index:
        log.warning(f&#34;Initial and final index are the same. I am recomputing the last point of historical prediction.&#34;)
        current_index = current_index - delta_time * hist_pred_delta

    iterations = 0
    cur = current_index
    fin = final_index

    while cur + delta_time * hist_pred_delta &lt;= fin:
        cur += delta_time * hist_pred_delta
        iterations += 1

    additional_computation = cur != fin
    log.debug(f&#34;Historical computations iterations: {iterations}&#34;)
    log.debug(f&#34;Historical additional computation: {additional_computation}&#34;)

    for i in range(0, iterations):
        available_data = ingested_data[:current_index]  # Remember: this includes current_index
        log.info(f&#34;Using data from {available_data.index[0]} to {current_index} for training...&#34;)

        timeseries_containers = get_best_predictions(available_data, param_config)

        log.info(f&#34;Assigning the historical predictions from {current_index + delta_time} to &#34;
                 f&#34;{current_index + hist_pred_delta * delta_time}&#34;)
        for s in timeseries_containers:
            for model in s.models:
                p = s.models[model].best_prediction
                timeseries_name = s.timeseries_data.columns[0]
                next_preds = p.loc[current_index + delta_time:current_index + hist_pred_delta * delta_time, &#39;yhat&#39;]

                for index, value in next_preds.items():
                    historical_prediction[model].loc[index, timeseries_name] = value

        current_index += delta_time * hist_pred_delta

        log.info(f&#34;Saving partial historical prediction to file...&#34;)
        with open(save_path, &#39;wb&#39;) as file:
            pickle.dump(historical_prediction, file, protocol=pickle.HIGHEST_PROTOCOL)

    if additional_computation:
        log.info(f&#34;Remaining data less than requested delta time. Computing the best predictions with last data...&#34;)
        available_data = ingested_data[:current_index]  # Remember: this includes current_index
        log.info(f&#34;Using data from {available_data.index[0]} to {current_index} for training...&#34;)

        timeseries_containers = get_best_predictions(available_data, param_config)

        log.info(f&#34;Assigning the historical predictions from {current_index + delta_time} to &#34;
                 f&#34;{final_index}&#34;)
        for s in timeseries_containers:
            for model in s.models:
                p = s.models[model].best_prediction
                timeseries_name = s.timeseries_data.columns[0]
                next_preds = p.loc[current_index + delta_time:final_index, &#39;yhat&#39;]

                for index, value in next_preds.items():
                    historical_prediction[model].loc[index, timeseries_name] = value

        log.info(f&#34;Saving partial historical prediction to file...&#34;)
        with open(save_path, &#39;wb&#39;) as file:
            pickle.dump(historical_prediction, file, protocol=pickle.HIGHEST_PROTOCOL)

    available_data = ingested_data
    timeseries_containers = get_best_predictions(available_data, param_config)

    for s in timeseries_containers:
        timeseries_name = s.timeseries_data.columns[0]
        timeseries_historical_predictions = {}
        for model in historical_prediction:
            timeseries_historical_predictions[model] = DataFrame(historical_prediction[model].loc[:, timeseries_name])
        s.set_historical_prediction(timeseries_historical_predictions)

    return timeseries_containers


def create_timeseries_containers(ingested_data: DataFrame, param_config: dict):
    &#34;&#34;&#34;
    Entry points of the pipeline; it will compute univariate/multivariate predictions, historical predictions, or only
    create the containers with the time-series data, according to the content of `param_config`, with this logic:

    - if `historical_prediction_parameters` is in `param_config`, then `compute_historical_predictions` will be called;
    - else, if `model_parameters` is in `param_config`, then `get_best_predictions` will be called;
    - else, create a list of `timexseries.timeseries_container.TimeSeriesContainer` with only the time-series data and, if
      `xcorr_parameters` is in `param_config`, with also the cross-correlation.

    Parameters
    ----------
    ingested_data : DataFrame
        Initial data of the time-series.

    param_config : dict
        TIMEX configuration dictionary.

    Returns
    -------
    list
        A list of `timexseries.timeseries_container.TimeSeriesContainer` objects, one for each time-series.

    Examples
    --------
    The first example of `compute_historical_predictions` applies also here; calling `create_timeseries_containers` will
    produce the same identical result.

    If we remove `historical_prediction_parameters` from the `param_config`, then calling this function is the same as
    calling `get_best_predictions`.

    However, if no predictions should be made but we just want the time-series containers:
    &gt;&gt;&gt; dates = pd.date_range(&#39;2000-01-01&#39;, periods=30)  # Last index is 2000-01-30
    &gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&#34;D&#34;)
    &gt;&gt;&gt; a = np.arange(30, 60)
    &gt;&gt;&gt; b = np.arange(60, 90)
    &gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&#34;a&#34;: a, &#34;b&#34;: b}, index=ds)

    Create the containers:
    &gt;&gt;&gt; param_config = {}
    &gt;&gt;&gt; timeseries_outputs = create_timeseries_containers(timeseries_dataframe, param_config)

    Check that no models, no historical predictions and no cross-correlation are present in the containers:
    &gt;&gt;&gt; print(timeseries_outputs[0].models)
    None
    &gt;&gt;&gt; print(timeseries_outputs[0].historical_prediction)
    None
    &gt;&gt;&gt; print(timeseries_outputs[0].xcorr)
    None

    If `xcorr_parameters` was specified, then the last command would not return None.
    Check that the time-series data is there:

    &gt;&gt;&gt; print(timeseries_outputs[0].timeseries_data)
                 a
    2000-01-01  30
    2000-01-02  31
    ...
    2000-01-29  58
    2000-01-30  59
    &#34;&#34;&#34;
    if &#34;historical_prediction_parameters&#34; in param_config:
        log.debug(f&#34;Requested the computation of historical predictions.&#34;)
        timeseries_containers = compute_historical_predictions(ingested_data, param_config)
    else:
        if &#34;model_parameters&#34; in param_config:
            log.debug(f&#34;Computing best predictions, without history.&#34;)
            timeseries_containers = get_best_predictions(ingested_data, param_config)
        else:
            log.debug(f&#34;Creating containers only for data visualization.&#34;)
            timeseries_containers = []
            if &#34;xcorr_parameters&#34; in param_config and len(ingested_data.columns) &gt; 1:
                total_xcorr = calc_all_xcorr(ingested_data=ingested_data, param_config=param_config)
            else:
                total_xcorr = None

            for col in ingested_data.columns:
                timeseries_data = ingested_data[[col]]
                timeseries_xcorr = total_xcorr[col] if total_xcorr is not None else None
                timeseries_containers.append(
                    TimeSeriesContainer(timeseries_data, None, timeseries_xcorr)
                )

    return timeseries_containers


def model_factory(model_class: str, param_config: dict, transformation: str = None) -&gt; PredictionModel:
    &#34;&#34;&#34;
    Given the name of the model, return the corresponding PredictionModel.

    Parameters
    ----------
    model_class : str
        Model type, e.g. &#34;fbprophet&#34;
    param_config : dict
        TIMEX configuration dictionary, to pass to the just created model.
    transformation : str, optional, default None
        Optional `transformation` parameter to pass to the just created model.

    Returns
    -------
    PredictionModel
        Prediction model of the class specified in `model_class`.

    Examples
    --------
    &gt;&gt;&gt; param_config = {
    ...    &#34;model_parameters&#34;: {
    ...        &#34;possible_transformations&#34;: &#34;none,log_modified&#34;,
    ...        &#34;main_accuracy_estimator&#34;: &#34;mae&#34;,
    ...        &#34;delta_training_percentage&#34;: 20,
    ...        &#34;test_values&#34;: 5,
    ...        &#34;prediction_lags&#34;: 7,
    ...    },
    ...}

    &gt;&gt;&gt; model = model_factory(&#34;fbprophet&#34;, param_config, &#34;none&#34;)
    &gt;&gt;&gt; print(type(model))
    &lt;class &#39;timexseries.data_prediction.models.prophet_predictor.FBProphetModel&#39;&gt;
    &#34;&#34;&#34;
    model_class = model_class.lower()
    if model_class == &#34;fbprophet&#34;:
        return FBProphetModel(params=param_config, transformation=transformation)
    if model_class == &#34;lstm&#34;:
        return LSTMModel(param_config, transformation)
    # if model_class == &#34;neuralprophet&#34;:
    #     return NeuralProphetModel(param_config, transformation)
    if model_class == &#34;mockup&#34;:
        return MockUpModel(param_config, transformation)
    if model_class == &#34;exponentialsmoothing&#34;:
        return ExponentialSmoothingModel(param_config, transformation)
    else:
        return ARIMAModel(params=param_config, transformation=transformation)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="timexseries.data_prediction.pipeline.compute_historical_predictions"><code class="name flex">
<span>def <span class="ident">compute_historical_predictions</span></span>(<span>ingested_data, param_config)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the historical predictions, i.e. the predictions for (part) of the history of the time-series.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ingested_data</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Initial data of the time-series.</dd>
<dt><strong><code>param_config</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>TIMEX configuration dictionary. In particular, the <code>historical_prediction_parameters</code> sub-dictionary will be
used. In <code>historical_prediction_parameters</code> the following options has to be specified:</p>
<ul>
<li><code>initial_index</code>: the point from which the historical computations will be made;</li>
<li><code>save_path</code>: the historical computations are saved on a file, serialized with pickle. This allows the re-use
of these predictions if TIMEX is restarted in the future.</li>
</ul>
<p>Additionally, the parameter <code>delta</code> can be specified: this indicates how many data points should be predicted
every run. The default is <code>1</code>; a number greater than <code>1</code> will reduce the accuracy of the predictions because
multiple points are predicted with the same model, but it will speed up the computation.</p>
<p><code>input_parameters</code> will be used because the <code>initial_index</code> date will be parsed with the same format provided in
<code>input_parameters</code>, if any. Otherwise the standard <code>yyyy-mm-dd</code> format will be used.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> objects, one for each time-series. These containers
have the <code>historical_prediction</code> attribute; the predictions in <code>model_results</code> are the more recent available
ones.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Historical predictions are predictions computed on past points of the time-series, but using only the data available
until that point.</p>
<p>Consider a time-series with length <code>p</code>. Consider that we want to find the historical predictions starting from the
middle of the time-series, i.e. from index <code>s=p/2</code>.</p>
<p>To do that, we take the data available from the start of the time-series to <code>s</code>, compute the prediction for the
instant <code>s + 1</code>, and then move forward.</p>
<p>When all the data has been used, we have <code>s</code> predictions, but also the real data corresponding to that predictions;
this allows the user to check error metrics and understand the real performances of a model, on data never seen.</p>
<p>These metrics can give an idea of the future performance of the model.</p>
<h2 id="examples">Examples</h2>
<p>Create some sample data.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dates = pd.date_range('2000-01-01', periods=30)  # Last index is 2000-01-30
&gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&quot;D&quot;)
&gt;&gt;&gt; a = np.arange(30, 60)
&gt;&gt;&gt; b = np.arange(60, 90)
&gt;&gt;&gt;
&gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&quot;a&quot;: a, &quot;b&quot;: b}, index=ds)
</code></pre>
<p>Create the configuration parameters dictionary:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; param_config = {
...     &quot;input_parameters&quot;: {
...     },
...     &quot;model_parameters&quot;: {
...         &quot;models&quot;: &quot;fbprophet&quot;,
...         &quot;possible_transformations&quot;: &quot;none,log_modified&quot;,
...         &quot;main_accuracy_estimator&quot;: &quot;mae&quot;,
...         &quot;delta_training_percentage&quot;: 20,
...         &quot;test_values&quot;: 5,
...         &quot;prediction_lags&quot;: 7,
...     },
...     &quot;historical_prediction_parameters&quot;: {
...         &quot;initial_index&quot;: &quot;2000-01-25&quot;,
...         &quot;save_path&quot;: &quot;example.pkl&quot;
...     }
... }
</code></pre>
<p>Launch the computation.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; timeseries_outputs = compute_historical_predictions(timeseries_dataframe, param_config)
</code></pre>
<p>Similarly to <code><a title="timexseries.data_prediction.pipeline.get_best_predictions" href="#timexseries.data_prediction.pipeline.get_best_predictions">get_best_predictions()</a></code>, we have a list of <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> objects.
However, these objects also have an historical prediction:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; timeseries_outputs[0].historical_prediction
{'fbprophet':                  a
             2000-01-26       55
             2000-01-27       56
             2000-01-28  56.3552
             2000-01-29  58.1709
             2000-01-30  58.9167
}
</code></pre>
<p>If multiple models were specified, <code>historical_prediction</code> dictionary would have other entries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_historical_predictions(ingested_data, param_config):
    &#34;&#34;&#34;
    Compute the historical predictions, i.e. the predictions for (part) of the history of the time-series.

    Parameters
    ----------
    ingested_data : DataFrame
        Initial data of the time-series.
    param_config : dict
        TIMEX configuration dictionary. In particular, the `historical_prediction_parameters` sub-dictionary will be
        used. In `historical_prediction_parameters` the following options has to be specified:

        - `initial_index`: the point from which the historical computations will be made;
        - `save_path`: the historical computations are saved on a file, serialized with pickle. This allows the re-use
        of these predictions if TIMEX is restarted in the future.

        Additionally, the parameter `delta` can be specified: this indicates how many data points should be predicted
        every run. The default is `1`; a number greater than `1` will reduce the accuracy of the predictions because
        multiple points are predicted with the same model, but it will speed up the computation.

        `input_parameters` will be used because the `initial_index` date will be parsed with the same format provided in
        `input_parameters`, if any. Otherwise the standard `yyyy-mm-dd` format will be used.

    Returns
    -------
    list
        A list of `timexseries.timeseries_container.TimeSeriesContainer` objects, one for each time-series. These containers
        have the `historical_prediction` attribute; the predictions in `model_results` are the more recent available
        ones.

    Notes
    -----
    Historical predictions are predictions computed on past points of the time-series, but using only the data available
    until that point.

    Consider a time-series with length `p`. Consider that we want to find the historical predictions starting from the
    middle of the time-series, i.e. from index `s=p/2`.

    To do that, we take the data available from the start of the time-series to `s`, compute the prediction for the
    instant `s + 1`, and then move forward.

    When all the data has been used, we have `s` predictions, but also the real data corresponding to that predictions;
    this allows the user to check error metrics and understand the real performances of a model, on data never seen.

    These metrics can give an idea of the future performance of the model.

    Examples
    --------
    Create some sample data.
    &gt;&gt;&gt; dates = pd.date_range(&#39;2000-01-01&#39;, periods=30)  # Last index is 2000-01-30
    &gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&#34;D&#34;)
    &gt;&gt;&gt; a = np.arange(30, 60)
    &gt;&gt;&gt; b = np.arange(60, 90)
    &gt;&gt;&gt;
    &gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&#34;a&#34;: a, &#34;b&#34;: b}, index=ds)

    Create the configuration parameters dictionary:
    &gt;&gt;&gt; param_config = {
    ...     &#34;input_parameters&#34;: {
    ...     },
    ...     &#34;model_parameters&#34;: {
    ...         &#34;models&#34;: &#34;fbprophet&#34;,
    ...         &#34;possible_transformations&#34;: &#34;none,log_modified&#34;,
    ...         &#34;main_accuracy_estimator&#34;: &#34;mae&#34;,
    ...         &#34;delta_training_percentage&#34;: 20,
    ...         &#34;test_values&#34;: 5,
    ...         &#34;prediction_lags&#34;: 7,
    ...     },
    ...     &#34;historical_prediction_parameters&#34;: {
    ...         &#34;initial_index&#34;: &#34;2000-01-25&#34;,
    ...         &#34;save_path&#34;: &#34;example.pkl&#34;
    ...     }
    ... }

    Launch the computation.
    &gt;&gt;&gt; timeseries_outputs = compute_historical_predictions(timeseries_dataframe, param_config)

    Similarly to `get_best_predictions`, we have a list of `timexseries.timeseries_container.TimeSeriesContainer` objects.
    However, these objects also have an historical prediction:
    &gt;&gt;&gt; timeseries_outputs[0].historical_prediction
    {&#39;fbprophet&#39;:                  a
                 2000-01-26       55
                 2000-01-27       56
                 2000-01-28  56.3552
                 2000-01-29  58.1709
                 2000-01-30  58.9167
    }

    If multiple models were specified, `historical_prediction` dictionary would have other entries.
    &#34;&#34;&#34;
    input_parameters = param_config[&#34;input_parameters&#34;]
    models = [*param_config[&#34;model_parameters&#34;][&#34;models&#34;].split(&#34;,&#34;)]
    save_path = param_config[&#34;historical_prediction_parameters&#34;][&#34;save_path&#34;]
    try:
        hist_pred_delta = param_config[&#34;historical_prediction_parameters&#34;][&#34;delta&#34;]
    except KeyError:
        hist_pred_delta = 1

    try:
        with open(save_path, &#39;rb&#39;) as file:
            historical_prediction = pickle.load(file)
        log.info(f&#34;Loaded historical prediction from file...&#34;)
        current_index = historical_prediction[models[0]].index[-1]
    except FileNotFoundError:
        log.info(f&#34;Historical prediction file not found: computing from the start...&#34;)
        starting_index = param_config[&#34;historical_prediction_parameters&#34;][&#34;initial_index&#34;]

        if &#34;dateparser_options&#34; in input_parameters:
            dateparser_options = input_parameters[&#34;dateparser_options&#34;]
            current_index = dateparser.parse(starting_index, **dateparser_options)
        else:
            current_index = dateparser.parse(starting_index)

        historical_prediction = {}
        for model in models:
            historical_prediction[model] = DataFrame(columns=ingested_data.columns)

    final_index = ingested_data.index[-1]
    log.info(f&#34;Starting index: {current_index}&#34;)
    log.info(f&#34;Final index: {final_index}&#34;)
    delta_time = 1 * ingested_data.index.freq

    if current_index == final_index:
        log.warning(f&#34;Initial and final index are the same. I am recomputing the last point of historical prediction.&#34;)
        current_index = current_index - delta_time * hist_pred_delta

    iterations = 0
    cur = current_index
    fin = final_index

    while cur + delta_time * hist_pred_delta &lt;= fin:
        cur += delta_time * hist_pred_delta
        iterations += 1

    additional_computation = cur != fin
    log.debug(f&#34;Historical computations iterations: {iterations}&#34;)
    log.debug(f&#34;Historical additional computation: {additional_computation}&#34;)

    for i in range(0, iterations):
        available_data = ingested_data[:current_index]  # Remember: this includes current_index
        log.info(f&#34;Using data from {available_data.index[0]} to {current_index} for training...&#34;)

        timeseries_containers = get_best_predictions(available_data, param_config)

        log.info(f&#34;Assigning the historical predictions from {current_index + delta_time} to &#34;
                 f&#34;{current_index + hist_pred_delta * delta_time}&#34;)
        for s in timeseries_containers:
            for model in s.models:
                p = s.models[model].best_prediction
                timeseries_name = s.timeseries_data.columns[0]
                next_preds = p.loc[current_index + delta_time:current_index + hist_pred_delta * delta_time, &#39;yhat&#39;]

                for index, value in next_preds.items():
                    historical_prediction[model].loc[index, timeseries_name] = value

        current_index += delta_time * hist_pred_delta

        log.info(f&#34;Saving partial historical prediction to file...&#34;)
        with open(save_path, &#39;wb&#39;) as file:
            pickle.dump(historical_prediction, file, protocol=pickle.HIGHEST_PROTOCOL)

    if additional_computation:
        log.info(f&#34;Remaining data less than requested delta time. Computing the best predictions with last data...&#34;)
        available_data = ingested_data[:current_index]  # Remember: this includes current_index
        log.info(f&#34;Using data from {available_data.index[0]} to {current_index} for training...&#34;)

        timeseries_containers = get_best_predictions(available_data, param_config)

        log.info(f&#34;Assigning the historical predictions from {current_index + delta_time} to &#34;
                 f&#34;{final_index}&#34;)
        for s in timeseries_containers:
            for model in s.models:
                p = s.models[model].best_prediction
                timeseries_name = s.timeseries_data.columns[0]
                next_preds = p.loc[current_index + delta_time:final_index, &#39;yhat&#39;]

                for index, value in next_preds.items():
                    historical_prediction[model].loc[index, timeseries_name] = value

        log.info(f&#34;Saving partial historical prediction to file...&#34;)
        with open(save_path, &#39;wb&#39;) as file:
            pickle.dump(historical_prediction, file, protocol=pickle.HIGHEST_PROTOCOL)

    available_data = ingested_data
    timeseries_containers = get_best_predictions(available_data, param_config)

    for s in timeseries_containers:
        timeseries_name = s.timeseries_data.columns[0]
        timeseries_historical_predictions = {}
        for model in historical_prediction:
            timeseries_historical_predictions[model] = DataFrame(historical_prediction[model].loc[:, timeseries_name])
        s.set_historical_prediction(timeseries_historical_predictions)

    return timeseries_containers</code></pre>
</details>
</dd>
<dt id="timexseries.data_prediction.pipeline.create_timeseries_containers"><code class="name flex">
<span>def <span class="ident">create_timeseries_containers</span></span>(<span>ingested_data: pandas.core.frame.DataFrame, param_config: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Entry points of the pipeline; it will compute univariate/multivariate predictions, historical predictions, or only
create the containers with the time-series data, according to the content of <code>param_config</code>, with this logic:</p>
<ul>
<li>if <code>historical_prediction_parameters</code> is in <code>param_config</code>, then <code><a title="timexseries.data_prediction.pipeline.compute_historical_predictions" href="#timexseries.data_prediction.pipeline.compute_historical_predictions">compute_historical_predictions()</a></code> will be called;</li>
<li>else, if <code>model_parameters</code> is in <code>param_config</code>, then <code><a title="timexseries.data_prediction.pipeline.get_best_predictions" href="#timexseries.data_prediction.pipeline.get_best_predictions">get_best_predictions()</a></code> will be called;</li>
<li>else, create a list of <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> with only the time-series data and, if
<code>xcorr_parameters</code> is in <code>param_config</code>, with also the cross-correlation.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ingested_data</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Initial data of the time-series.</dd>
<dt><strong><code>param_config</code></strong> :&ensp;<code>dict</code></dt>
<dd>TIMEX configuration dictionary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> objects, one for each time-series.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>The first example of <code><a title="timexseries.data_prediction.pipeline.compute_historical_predictions" href="#timexseries.data_prediction.pipeline.compute_historical_predictions">compute_historical_predictions()</a></code> applies also here; calling <code><a title="timexseries.data_prediction.pipeline.create_timeseries_containers" href="#timexseries.data_prediction.pipeline.create_timeseries_containers">create_timeseries_containers()</a></code> will
produce the same identical result.</p>
<p>If we remove <code>historical_prediction_parameters</code> from the <code>param_config</code>, then calling this function is the same as
calling <code><a title="timexseries.data_prediction.pipeline.get_best_predictions" href="#timexseries.data_prediction.pipeline.get_best_predictions">get_best_predictions()</a></code>.</p>
<p>However, if no predictions should be made but we just want the time-series containers:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dates = pd.date_range('2000-01-01', periods=30)  # Last index is 2000-01-30
&gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&quot;D&quot;)
&gt;&gt;&gt; a = np.arange(30, 60)
&gt;&gt;&gt; b = np.arange(60, 90)
&gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&quot;a&quot;: a, &quot;b&quot;: b}, index=ds)
</code></pre>
<p>Create the containers:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; param_config = {}
&gt;&gt;&gt; timeseries_outputs = create_timeseries_containers(timeseries_dataframe, param_config)
</code></pre>
<p>Check that no models, no historical predictions and no cross-correlation are present in the containers:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; print(timeseries_outputs[0].models)
None
&gt;&gt;&gt; print(timeseries_outputs[0].historical_prediction)
None
&gt;&gt;&gt; print(timeseries_outputs[0].xcorr)
None
</code></pre>
<p>If <code>xcorr_parameters</code> was specified, then the last command would not return None.
Check that the time-series data is there:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; print(timeseries_outputs[0].timeseries_data)
             a
2000-01-01  30
2000-01-02  31
...
2000-01-29  58
2000-01-30  59
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_timeseries_containers(ingested_data: DataFrame, param_config: dict):
    &#34;&#34;&#34;
    Entry points of the pipeline; it will compute univariate/multivariate predictions, historical predictions, or only
    create the containers with the time-series data, according to the content of `param_config`, with this logic:

    - if `historical_prediction_parameters` is in `param_config`, then `compute_historical_predictions` will be called;
    - else, if `model_parameters` is in `param_config`, then `get_best_predictions` will be called;
    - else, create a list of `timexseries.timeseries_container.TimeSeriesContainer` with only the time-series data and, if
      `xcorr_parameters` is in `param_config`, with also the cross-correlation.

    Parameters
    ----------
    ingested_data : DataFrame
        Initial data of the time-series.

    param_config : dict
        TIMEX configuration dictionary.

    Returns
    -------
    list
        A list of `timexseries.timeseries_container.TimeSeriesContainer` objects, one for each time-series.

    Examples
    --------
    The first example of `compute_historical_predictions` applies also here; calling `create_timeseries_containers` will
    produce the same identical result.

    If we remove `historical_prediction_parameters` from the `param_config`, then calling this function is the same as
    calling `get_best_predictions`.

    However, if no predictions should be made but we just want the time-series containers:
    &gt;&gt;&gt; dates = pd.date_range(&#39;2000-01-01&#39;, periods=30)  # Last index is 2000-01-30
    &gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&#34;D&#34;)
    &gt;&gt;&gt; a = np.arange(30, 60)
    &gt;&gt;&gt; b = np.arange(60, 90)
    &gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&#34;a&#34;: a, &#34;b&#34;: b}, index=ds)

    Create the containers:
    &gt;&gt;&gt; param_config = {}
    &gt;&gt;&gt; timeseries_outputs = create_timeseries_containers(timeseries_dataframe, param_config)

    Check that no models, no historical predictions and no cross-correlation are present in the containers:
    &gt;&gt;&gt; print(timeseries_outputs[0].models)
    None
    &gt;&gt;&gt; print(timeseries_outputs[0].historical_prediction)
    None
    &gt;&gt;&gt; print(timeseries_outputs[0].xcorr)
    None

    If `xcorr_parameters` was specified, then the last command would not return None.
    Check that the time-series data is there:

    &gt;&gt;&gt; print(timeseries_outputs[0].timeseries_data)
                 a
    2000-01-01  30
    2000-01-02  31
    ...
    2000-01-29  58
    2000-01-30  59
    &#34;&#34;&#34;
    if &#34;historical_prediction_parameters&#34; in param_config:
        log.debug(f&#34;Requested the computation of historical predictions.&#34;)
        timeseries_containers = compute_historical_predictions(ingested_data, param_config)
    else:
        if &#34;model_parameters&#34; in param_config:
            log.debug(f&#34;Computing best predictions, without history.&#34;)
            timeseries_containers = get_best_predictions(ingested_data, param_config)
        else:
            log.debug(f&#34;Creating containers only for data visualization.&#34;)
            timeseries_containers = []
            if &#34;xcorr_parameters&#34; in param_config and len(ingested_data.columns) &gt; 1:
                total_xcorr = calc_all_xcorr(ingested_data=ingested_data, param_config=param_config)
            else:
                total_xcorr = None

            for col in ingested_data.columns:
                timeseries_data = ingested_data[[col]]
                timeseries_xcorr = total_xcorr[col] if total_xcorr is not None else None
                timeseries_containers.append(
                    TimeSeriesContainer(timeseries_data, None, timeseries_xcorr)
                )

    return timeseries_containers</code></pre>
</details>
</dd>
<dt id="timexseries.data_prediction.pipeline.get_best_multivariate_predictions"><code class="name flex">
<span>def <span class="ident">get_best_multivariate_predictions</span></span>(<span>timeseries_containers: [<class '<a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a>'>], ingested_data: pandas.core.frame.DataFrame, best_transformations: dict, total_xcorr: dict, param_config: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Starting from the a list of <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code>, use the available univariated
predictions and the time-series in <code>ingested_data</code>, plus eventual user-given additional regressors to compute new
multivariate predictions.</p>
<p>These new predictions will be used only if better than the univariate ones.</p>
<p>Returns the updated list of <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeseries_containers</code></strong> :&ensp;<code>[TimeSeriesContainer]</code></dt>
<dd>Initial <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> list from which the computation of multivariate
predictions start. Some univariate predictions should be already present in each object: more formally, each
<code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> should have the <code>model_results</code> attribute.</dd>
<dt><strong><code>ingested_data</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Initial data of the time-series.</dd>
<dt><strong><code>best_transformations</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary which assigns the best transformation for every used prediction model, for every time-series. It
should be returned by <code><a title="timexseries.data_prediction.pipeline.get_best_univariate_predictions" href="#timexseries.data_prediction.pipeline.get_best_univariate_predictions">get_best_univariate_predictions()</a></code>.</dd>
<dt><strong><code>total_xcorr</code></strong> :&ensp;<code>dict</code></dt>
<dd>Cross-correlation dictionary computed by <code><a title="timexseries.data_prediction.xcorr.calc_all_xcorr" href="xcorr.html#timexseries.data_prediction.xcorr.calc_all_xcorr">calc_all_xcorr()</a></code>. The cross-correlation is
used in this function, to find, among all the time-series in <code>ingested_data</code>, additional regressors for each
time-series, if there are some.</dd>
<dt><strong><code>param_config</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>TIMEX configuration dictionary. In particular, the <code>xcorr_parameters</code> sub-dictionary will be used. In
<code>xcorr_parameters</code> the following options has to be specified if <code>total_xcorr</code> parameter is not None:</p>
<ul>
<li><code>xcorr_mode_target</code>: which cross-correlation algorithm should be used as target in evaluating useful
additional regressors. E.g. "pearson".</li>
<li><code>xcorr_extra_regressor_threshold</code>: the minimum absolute value of cross-correlation which indicates a useful
extra-regressor. E.g. 0.8.</li>
</ul>
<p>Additionally, the <code>additional_regressors</code> part of the TIMEX configuration parameter dictionary can be used by
the user to specify additional CSV paths to time-series data to use as extra-regressor.
It should be a dictionary in the form "target time-series": "path of the additional extra-regressors".
The key "_all" is a special key which indicates a path to additional extra-regressors which will be used for
any time-series.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> objects, one for each time-series.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>We will create ad-hoc time-series in which using a multivariate model will perform better than using a univariate
one.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dates = pd.date_range('2000-01-01', periods=30)  # Last index is 2000-01-30
&gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&quot;D&quot;)
&gt;&gt;&gt;
&gt;&gt;&gt; x = np.linspace(0, 2 * np.pi, 60)
&gt;&gt;&gt; y = np.sin(x)
&gt;&gt;&gt;
&gt;&gt;&gt; np.random.seed(0)
&gt;&gt;&gt; noise = np.random.normal(0, 2.0, 60)
&gt;&gt;&gt; y = y + noise
&gt;&gt;&gt;
&gt;&gt;&gt; a = y[:30]
&gt;&gt;&gt; b = y[5:35]
&gt;&gt;&gt;
&gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&quot;a&quot;: a, &quot;b&quot;: b}, index=ds)
</code></pre>
<p>In this dataset the time-series <code>b</code> can be used to better predict <code>a</code>&hellip; simply because it is the same series, but
traslated!</p>
<p>Try to perform the computations.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; param_config = {
...     &quot;model_parameters&quot;: {
...         &quot;models&quot;: &quot;LSTM&quot;,
...         &quot;possible_transformations&quot;: &quot;none,log_modified&quot;,
...         &quot;main_accuracy_estimator&quot;: &quot;mae&quot;,
...         &quot;delta_training_percentage&quot;: 20,
...         &quot;test_values&quot;: 5,
...         &quot;prediction_lags&quot;: 7,
...     },
...     &quot;xcorr_parameters&quot;: {
...         &quot;xcorr_mode_target&quot;: &quot;pearson&quot;,
...         &quot;xcorr_extra_regressor_threshold&quot;: 0.7,
...         &quot;xcorr_max_lags&quot;: 6,
...         &quot;xcorr_mode&quot;: &quot;pearson&quot;
...     }
... }
&gt;&gt;&gt; xcorr = calc_all_xcorr(timeseries_dataframe, param_config)
&gt;&gt;&gt; best_transformations, timeseries_outputs = get_best_univariate_predictions(timeseries_dataframe, param_config)
&gt;&gt;&gt; timeseries_outputs = get_best_multivariate_predictions(timeseries_outputs, timeseries_dataframe,
&gt;&gt;&gt;                                                        best_transformations, xcorr, param_config)
</code></pre>
<p>From the log, we can see:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; &quot;INFO:timexseries.data_prediction.pipeline:Found useful extra-regressors: Index(['b'], dtype='object'). Re-compute the prediction for a&quot;
&gt;&gt;&gt; &quot;INFO:timexseries.data_prediction.models.predictor:Creating a LSTM model...&quot;
&gt;&gt;&gt; &quot;INFO:timexseries.data_prediction.models.predictor:Model will use 5 different training sets...&quot;
&gt;&gt;&gt; &quot;INFO:timexseries.data_prediction.models.predictor:LSTM/NeuralProphet model. Cant use multiprocessing.&quot;
&gt;&gt;&gt; &quot;INFO:timexseries.data_prediction.pipeline:Obtained a better error: 1.6009327718008979 vs old 1.9918351002921089&quot;
</code></pre>
<p>This means that using <code>b</code> as additional regressor for <code>a</code> made us obtain a better error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_multivariate_predictions(timeseries_containers: [TimeSeriesContainer], ingested_data: DataFrame,
                                      best_transformations: dict, total_xcorr: dict, param_config: dict):
    &#34;&#34;&#34;
    Starting from the a list of `timexseries.timeseries_container.TimeSeriesContainer`, use the available univariated
    predictions and the time-series in `ingested_data`, plus eventual user-given additional regressors to compute new
    multivariate predictions.

    These new predictions will be used only if better than the univariate ones.

    Returns the updated list of `timexseries.timeseries_container.TimeSeriesContainer`.

    Parameters
    ----------
    timeseries_containers : [TimeSeriesContainer]
        Initial `timexseries.timeseries_container.TimeSeriesContainer` list from which the computation of multivariate
        predictions start. Some univariate predictions should be already present in each object: more formally, each
        `timexseries.timeseries_container.TimeSeriesContainer` should have the `model_results` attribute.
    ingested_data : DataFrame
        Initial data of the time-series.
    best_transformations : dict
        Dictionary which assigns the best transformation for every used prediction model, for every time-series. It
        should be returned by `get_best_univariate_predictions`.
    total_xcorr : dict
        Cross-correlation dictionary computed by `timexseries.data_prediction.xcorr.calc_all_xcorr`. The cross-correlation is
        used in this function, to find, among all the time-series in `ingested_data`, additional regressors for each
        time-series, if there are some.
    param_config : dict
        TIMEX configuration dictionary. In particular, the `xcorr_parameters` sub-dictionary will be used. In
        `xcorr_parameters` the following options has to be specified if `total_xcorr` parameter is not None:

        - `xcorr_mode_target`: which cross-correlation algorithm should be used as target in evaluating useful
          additional regressors. E.g. &#34;pearson&#34;.
        - `xcorr_extra_regressor_threshold`: the minimum absolute value of cross-correlation which indicates a useful
          extra-regressor. E.g. 0.8.

        Additionally, the `additional_regressors` part of the TIMEX configuration parameter dictionary can be used by
        the user to specify additional CSV paths to time-series data to use as extra-regressor.
        It should be a dictionary in the form &#34;target time-series&#34;: &#34;path of the additional extra-regressors&#34;.
        The key &#34;_all&#34; is a special key which indicates a path to additional extra-regressors which will be used for
        any time-series.

    Returns
    -------
    list
        A list of `timexseries.timeseries_container.TimeSeriesContainer` objects, one for each time-series.

    Examples
    --------
    We will create ad-hoc time-series in which using a multivariate model will perform better than using a univariate
    one.

    &gt;&gt;&gt; dates = pd.date_range(&#39;2000-01-01&#39;, periods=30)  # Last index is 2000-01-30
    &gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&#34;D&#34;)
    &gt;&gt;&gt;
    &gt;&gt;&gt; x = np.linspace(0, 2 * np.pi, 60)
    &gt;&gt;&gt; y = np.sin(x)
    &gt;&gt;&gt;
    &gt;&gt;&gt; np.random.seed(0)
    &gt;&gt;&gt; noise = np.random.normal(0, 2.0, 60)
    &gt;&gt;&gt; y = y + noise
    &gt;&gt;&gt;
    &gt;&gt;&gt; a = y[:30]
    &gt;&gt;&gt; b = y[5:35]
    &gt;&gt;&gt;
    &gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&#34;a&#34;: a, &#34;b&#34;: b}, index=ds)

    In this dataset the time-series `b` can be used to better predict `a`... simply because it is the same series, but
    traslated!

    Try to perform the computations.

    &gt;&gt;&gt; param_config = {
    ...     &#34;model_parameters&#34;: {
    ...         &#34;models&#34;: &#34;LSTM&#34;,
    ...         &#34;possible_transformations&#34;: &#34;none,log_modified&#34;,
    ...         &#34;main_accuracy_estimator&#34;: &#34;mae&#34;,
    ...         &#34;delta_training_percentage&#34;: 20,
    ...         &#34;test_values&#34;: 5,
    ...         &#34;prediction_lags&#34;: 7,
    ...     },
    ...     &#34;xcorr_parameters&#34;: {
    ...         &#34;xcorr_mode_target&#34;: &#34;pearson&#34;,
    ...         &#34;xcorr_extra_regressor_threshold&#34;: 0.7,
    ...         &#34;xcorr_max_lags&#34;: 6,
    ...         &#34;xcorr_mode&#34;: &#34;pearson&#34;
    ...     }
    ... }
    &gt;&gt;&gt; xcorr = calc_all_xcorr(timeseries_dataframe, param_config)
    &gt;&gt;&gt; best_transformations, timeseries_outputs = get_best_univariate_predictions(timeseries_dataframe, param_config)
    &gt;&gt;&gt; timeseries_outputs = get_best_multivariate_predictions(timeseries_outputs, timeseries_dataframe,
    &gt;&gt;&gt;                                                        best_transformations, xcorr, param_config)

    From the log, we can see:
    &gt;&gt;&gt; &#34;INFO:timexseries.data_prediction.pipeline:Found useful extra-regressors: Index([&#39;b&#39;], dtype=&#39;object&#39;). Re-compute the prediction for a&#34;
    &gt;&gt;&gt; &#34;INFO:timexseries.data_prediction.models.predictor:Creating a LSTM model...&#34;
    &gt;&gt;&gt; &#34;INFO:timexseries.data_prediction.models.predictor:Model will use 5 different training sets...&#34;
    &gt;&gt;&gt; &#34;INFO:timexseries.data_prediction.models.predictor:LSTM/NeuralProphet model. Cant use multiprocessing.&#34;
    &gt;&gt;&gt; &#34;INFO:timexseries.data_prediction.pipeline:Obtained a better error: 1.6009327718008979 vs old 1.9918351002921089&#34;

    This means that using `b` as additional regressor for `a` made us obtain a better error.
    &#34;&#34;&#34;
    iterations = 0
    best_forecasts_found = 0

    if total_xcorr is not None:
        xcorr_mode_target = param_config[&#34;xcorr_parameters&#34;][&#34;xcorr_mode_target&#34;]
        xcorr_threshold = param_config[&#34;xcorr_parameters&#34;][&#34;xcorr_extra_regressor_threshold&#34;]

    try:
        additional_regressors = param_config[&#34;additional_regressors&#34;]
    except KeyError:
        additional_regressors = None

    models = [*param_config[&#34;model_parameters&#34;][&#34;models&#34;].split(&#34;,&#34;)]

    try:
        max_threads = param_config[&#39;max_threads&#39;]
    except KeyError:
        try:
            max_threads = len(os.sched_getaffinity(0))
        except:
            max_threads = 1

    for model in models:
        log.info(f&#34;Checking optimal predictions with model {model}&#34;)
        best_forecasts_found = 0
        iterations = 0

        while best_forecasts_found != len(ingested_data.columns):
            log.info(f&#34;-&gt; Found the optimal prediction for only {best_forecasts_found}&#34;)
            best_forecasts_found = 0

            for col in ingested_data.columns:
                depends_on_other_ts = False
                useful_extra_regressors = []

                log.debug(f&#34;Look for extra regressors in other dataset&#39;s columns...&#34;)
                try:
                    local_xcorr = total_xcorr[col][xcorr_mode_target]

                    # Add extra regressors from the original dataset
                    for extra_regressor in local_xcorr.columns:
                        # Look only in correlation with future lags.
                        index_of_max = local_xcorr[extra_regressor].abs().idxmax()
                        corr = local_xcorr.loc[index_of_max, extra_regressor]
                        if abs(corr) &gt; xcorr_threshold and index_of_max &gt;= 0:
                            log.debug(
                                f&#34;Found a possible extra-regressor for {col}: {extra_regressor} at lag {index_of_max}&#34;)

                            useful_extra_regressors.append(
                                prepare_extra_regressor(next(filter(
                                    lambda x: x.timeseries_data.columns[0] == extra_regressor, timeseries_containers)), model=model))
                            depends_on_other_ts = True
                    local_xcorr = total_xcorr[col]  # To give the full xcorr to Scenario
                except:
                    local_xcorr = None

                log.debug(f&#34;Look for user-given additional regressors...&#34;)
                try:
                    additional_regressor_path = additional_regressors[&#34;_all&#34;]
                    useful_extra_regressors.append(ingest_additional_regressors(additional_regressor_path, param_config))
                except:
                    pass

                try:
                    additional_regressor_path = additional_regressors[col]
                    useful_extra_regressors.append(ingest_additional_regressors(additional_regressor_path, param_config))
                except:
                    pass

                if len(useful_extra_regressors) == 0:
                    log.debug(f&#34;No useful extra-regressor found for {col}: skipping...&#34;)
                    best_forecasts_found += 1
                else:
                    useful_extra_regressors = reduce(lambda x, y: x.join(y), useful_extra_regressors)
                    log.info(f&#34;Found useful extra-regressors: {useful_extra_regressors.columns}. &#34;
                             f&#34;Re-compute the prediction for {col}&#34;)

                    timeseries_data = ingested_data[[col]]

                    tr = best_transformations[model][col]

                    predictor = model_factory(model, param_config, transformation=tr)
                    _result = predictor.launch_model(timeseries_data.copy(),
                                                     extra_regressors=useful_extra_regressors.copy(),
                                                     max_threads=max_threads)
                    old_this_container = next(filter(lambda x: x.timeseries_data.columns[0] == col, timeseries_containers))

                    old_errors = [x.testing_performances.MAE for x in old_this_container.models[model].results]
                    min_old_error = min(old_errors)
                    min_new_error = min([x.testing_performances.MAE for x in _result.results])

                    if min_new_error &lt; min_old_error:
                        log.info(f&#34;Obtained a better error: {min_new_error} vs old {min_old_error}&#34;)
                        new_model_results = old_this_container.models
                        new_model_results[model] = _result
                        new_container = TimeSeriesContainer(timeseries_data, new_model_results, local_xcorr)
                        timeseries_containers = [new_container if x.timeseries_data.columns[0] == col else x for x in timeseries_containers]
                        if not depends_on_other_ts:
                            best_forecasts_found += 1
                    else:
                        log.info(f&#34;No improvements.&#34;)
                        best_forecasts_found += 1
            iterations += 1

    log.info(f&#34;Found the optimal prediction for all the {best_forecasts_found} time-series in {iterations} iterations!&#34;)
    return timeseries_containers</code></pre>
</details>
</dd>
<dt id="timexseries.data_prediction.pipeline.get_best_predictions"><code class="name flex">
<span>def <span class="ident">get_best_predictions</span></span>(<span>ingested_data: pandas.core.frame.DataFrame, param_config: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Starting from <code>ingested_data</code>, using the models/cross correlation settings set in <code>param_config</code>, return the best
possible predictions in a <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> for each time-series in <code>ingested_data</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ingested_data</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Initial data of the time-series.</dd>
<dt><strong><code>param_config</code></strong> :&ensp;<code>dict</code></dt>
<dd>TIMEX configuration dictionary. <code><a title="timexseries.data_prediction.pipeline.get_best_univariate_predictions" href="#timexseries.data_prediction.pipeline.get_best_univariate_predictions">get_best_univariate_predictions()</a></code> and <code><a title="timexseries.data_prediction.pipeline.get_best_multivariate_predictions" href="#timexseries.data_prediction.pipeline.get_best_multivariate_predictions">get_best_multivariate_predictions()</a></code> will
use the various settings in <code>param_config</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> objects, one for each time-series.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>This is basically the function on top of <code><a title="timexseries.data_prediction.pipeline.get_best_univariate_predictions" href="#timexseries.data_prediction.pipeline.get_best_univariate_predictions">get_best_univariate_predictions()</a></code> and <code><a title="timexseries.data_prediction.pipeline.get_best_multivariate_predictions" href="#timexseries.data_prediction.pipeline.get_best_multivariate_predictions">get_best_multivariate_predictions()</a></code>:
it will call first the univariate and then the multivariate if the cross-correlation section is present
in <code>param_config</code>.</p>
<p>Create some data:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dates = pd.date_range('2000-01-01', periods=30)  # Last index is 2000-01-30
&gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&quot;D&quot;)
&gt;&gt;&gt; a = np.arange(30, 60)
&gt;&gt;&gt; b = np.arange(60, 90)
&gt;&gt;&gt;
&gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&quot;a&quot;: a, &quot;b&quot;: b}, index=ds)
</code></pre>
<p>Simply compute the predictions and get the returned <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> objects:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; timeseries_outputs = get_best_predictions(timeseries_dataframe, param_config)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_predictions(ingested_data: DataFrame, param_config: dict):
    &#34;&#34;&#34;
    Starting from `ingested_data`, using the models/cross correlation settings set in `param_config`, return the best
    possible predictions in a `timexseries.timeseries_container.TimeSeriesContainer` for each time-series in `ingested_data`.

    Parameters
    ----------
    ingested_data : DataFrame
        Initial data of the time-series.

    param_config : dict
        TIMEX configuration dictionary. `get_best_univariate_predictions` and `get_best_multivariate_predictions` will
        use the various settings in `param_config`.

    Returns
    -------
    list
        A list of `timexseries.timeseries_container.TimeSeriesContainer` objects, one for each time-series.

    Examples
    --------
    This is basically the function on top of `get_best_univariate_predictions` and `get_best_multivariate_predictions`:
    it will call first the univariate and then the multivariate if the cross-correlation section is present
    in `param_config`.

    Create some data:
    &gt;&gt;&gt; dates = pd.date_range(&#39;2000-01-01&#39;, periods=30)  # Last index is 2000-01-30
    &gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&#34;D&#34;)
    &gt;&gt;&gt; a = np.arange(30, 60)
    &gt;&gt;&gt; b = np.arange(60, 90)
    &gt;&gt;&gt;
    &gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&#34;a&#34;: a, &#34;b&#34;: b}, index=ds)

    Simply compute the predictions and get the returned `timexseries.timeseries_container.TimeSeriesContainer` objects:
    &gt;&gt;&gt; timeseries_outputs = get_best_predictions(timeseries_dataframe, param_config)
    &#34;&#34;&#34;
    if &#34;xcorr_parameters&#34; in param_config and len(ingested_data.columns) &gt; 1:
        log.info(f&#34;Computing the cross-correlation...&#34;)
        total_xcorr = calc_all_xcorr(ingested_data=ingested_data, param_config=param_config)
    else:
        total_xcorr = None

    best_transformations, timeseries_containers = get_best_univariate_predictions(ingested_data, param_config,
                                                                                  total_xcorr)

    if total_xcorr is not None or &#34;additional_regressors&#34; in param_config:
        timeseries_containers = get_best_multivariate_predictions(timeseries_containers=timeseries_containers, ingested_data=ingested_data,
                                                      best_transformations=best_transformations,
                                                      total_xcorr=total_xcorr,
                                                      param_config=param_config)

    return timeseries_containers</code></pre>
</details>
</dd>
<dt id="timexseries.data_prediction.pipeline.get_best_univariate_predictions"><code class="name flex">
<span>def <span class="ident">get_best_univariate_predictions</span></span>(<span>ingested_data: pandas.core.frame.DataFrame, param_config: dict, total_xcorr: dict = None) ‑> Tuple[dict, list]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute, for every column in <code>ingested_data</code> (every time-series) the best univariate prediction possible.
This is done using the models specified in <code>param_config</code> and testing the effect of the different transformations
specified in <code>param_config</code>. Moreover, the best feature transformation found, across the possible ones, will be
returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ingested_data</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Initial data of the time-series.</dd>
<dt><strong><code>param_config</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>TIMEX configuration dictionary. In particular, the <code>model_parameters</code> sub-dictionary will be used. In
<code>model_parameters</code> the following options has to be specified:</p>
<ul>
<li><code>possible_transformations</code>: comma-separated list of transformations keywords (e.g. "none,log_modified").</li>
<li><code>main_accuracy_estimator</code>: error metric which will be minimized as target by the procedure. E.g. "mae".</li>
<li><code>models</code>: comma-separated list of the models to use (e.g. "fbprophet,arima").</li>
</ul>
</dd>
<dt><strong><code>total_xcorr</code></strong> :&ensp;<code>dict</code>, optional, default <code>None</code></dt>
<dd>Cross-correlation dictionary computed by <code>calc_all_xcorr</code>. The cross-correlation is actually not used in this
function, however it is used to build the returned <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code>, if given.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary which assigns the best transformation for every used prediction model, for every time-series.</dd>
<dt><code>list</code></dt>
<dd>A list of <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> objects, one for each time-series.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Create some fake data:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; dates = pd.date_range('2000-01-01', periods=30)  # Last index is 2000-01-30
&gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&quot;D&quot;)
&gt;&gt;&gt; a = np.arange(30, 60)
&gt;&gt;&gt; b = np.arange(60, 90)
&gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&quot;a&quot;: a, &quot;b&quot;: b}, index=ds)
</code></pre>
<p>And create the model configuration part of the TIMEX configuration dictionary:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; param_config = {
...   &quot;model_parameters&quot;: {
...     &quot;models&quot;: &quot;fbprophet&quot;,  # Model(s) which will be tested.
...     &quot;possible_transformations&quot;: &quot;none,log_modified&quot;,  # Possible feature transformation to test.
...     &quot;main_accuracy_estimator&quot;: &quot;mae&quot;,
...     &quot;delta_training_percentage&quot;: 20,  # Training windows will be incremented by the 20% each step...
...     &quot;test_values&quot;: 5,  # Use the last 5 values as validation set.
...     &quot;prediction_lags&quot;: 7,  # Predict the next 7 points after 2000-01-30.
...     }
... }
</code></pre>
<p>Now, get the univariate predictions:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; best_transformations, timeseries_outputs = get_best_univariate_predictions(timeseries_dataframe, param_config)
</code></pre>
<p>Let's inspect the results. <code>best_transformations</code> contains the suggested feature transformations to use:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; best_transformations
{'fbprophet': {'a': 'none', 'b': 'none'}}
</code></pre>
<p>It is reasonable with this simple data that no transformation is the best transformation.
We have the <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> list as well:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; timeseries_outputs
[&lt;timexseries.timeseries_container.TimeSeriesContainer at 0x7f62f45d1fa0&gt;,
 &lt;timexseries.timeseries_container.TimeSeriesContainer at 0x7f62d4e97cd0&gt;]
</code></pre>
<p>These are the <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> objects, one for time-series <code>a</code> and one for <code>b</code>.
Each one has various fields, in this case the most interesting one is <code>models</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; timeseries_outputs[0].models
{'fbprophet': &lt;timexseries.data_prediction.models.predictor.ModelResult at 0x7f62f45d1d90&gt;}
</code></pre>
<p>This is the <code><a title="timexseries.data_prediction.models.predictor.ModelResult" href="models/predictor.html#timexseries.data_prediction.models.predictor.ModelResult">ModelResult</a></code> object for FBProphet that we have just computed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_univariate_predictions(ingested_data: DataFrame, param_config: dict, total_xcorr: dict = None) -&gt; \
        Tuple[dict, list]:
    &#34;&#34;&#34;
    Compute, for every column in `ingested_data` (every time-series) the best univariate prediction possible.
    This is done using the models specified in `param_config` and testing the effect of the different transformations
    specified in `param_config`. Moreover, the best feature transformation found, across the possible ones, will be
    returned.

    Parameters
    ----------
    ingested_data : DataFrame
        Initial data of the time-series.
    param_config : dict
        TIMEX configuration dictionary. In particular, the `model_parameters` sub-dictionary will be used. In
        `model_parameters` the following options has to be specified:

        - `possible_transformations`: comma-separated list of transformations keywords (e.g. &#34;none,log_modified&#34;).
        - `main_accuracy_estimator`: error metric which will be minimized as target by the procedure. E.g. &#34;mae&#34;.
        - `models`: comma-separated list of the models to use (e.g. &#34;fbprophet,arima&#34;).

    total_xcorr : dict, optional, default None
        Cross-correlation dictionary computed by `calc_all_xcorr`. The cross-correlation is actually not used in this
        function, however it is used to build the returned `timexseries.timeseries_container.TimeSeriesContainer`, if given.

    Returns
    -------
    dict
        Dictionary which assigns the best transformation for every used prediction model, for every time-series.
    list
        A list of `timexseries.timeseries_container.TimeSeriesContainer` objects, one for each time-series.

    Examples
    --------
    Create some fake data:
    &gt;&gt;&gt; dates = pd.date_range(&#39;2000-01-01&#39;, periods=30)  # Last index is 2000-01-30
    &gt;&gt;&gt; ds = pd.DatetimeIndex(dates, freq=&#34;D&#34;)
    &gt;&gt;&gt; a = np.arange(30, 60)
    &gt;&gt;&gt; b = np.arange(60, 90)
    &gt;&gt;&gt; timeseries_dataframe = DataFrame(data={&#34;a&#34;: a, &#34;b&#34;: b}, index=ds)

    And create the model configuration part of the TIMEX configuration dictionary:
    &gt;&gt;&gt; param_config = {
    ...   &#34;model_parameters&#34;: {
    ...     &#34;models&#34;: &#34;fbprophet&#34;,  # Model(s) which will be tested.
    ...     &#34;possible_transformations&#34;: &#34;none,log_modified&#34;,  # Possible feature transformation to test.
    ...     &#34;main_accuracy_estimator&#34;: &#34;mae&#34;,
    ...     &#34;delta_training_percentage&#34;: 20,  # Training windows will be incremented by the 20% each step...
    ...     &#34;test_values&#34;: 5,  # Use the last 5 values as validation set.
    ...     &#34;prediction_lags&#34;: 7,  # Predict the next 7 points after 2000-01-30.
    ...     }
    ... }

    Now, get the univariate predictions:
    &gt;&gt;&gt; best_transformations, timeseries_outputs = get_best_univariate_predictions(timeseries_dataframe, param_config)

    Let&#39;s inspect the results. `best_transformations` contains the suggested feature transformations to use:
    &gt;&gt;&gt; best_transformations
    {&#39;fbprophet&#39;: {&#39;a&#39;: &#39;none&#39;, &#39;b&#39;: &#39;none&#39;}}

    It is reasonable with this simple data that no transformation is the best transformation.
    We have the `timexseries.timeseries_container.TimeSeriesContainer` list as well:
    &gt;&gt;&gt; timeseries_outputs
    [&lt;timexseries.timeseries_container.TimeSeriesContainer at 0x7f62f45d1fa0&gt;,
     &lt;timexseries.timeseries_container.TimeSeriesContainer at 0x7f62d4e97cd0&gt;]

    These are the `timexseries.timeseries_container.TimeSeriesContainer` objects, one for time-series `a` and one for `b`.
    Each one has various fields, in this case the most interesting one is `models`:
    &gt;&gt;&gt; timeseries_outputs[0].models
    {&#39;fbprophet&#39;: &lt;timexseries.data_prediction.models.predictor.ModelResult at 0x7f62f45d1d90&gt;}

    This is the `timexseries.data_prediction.models.predictor.ModelResult` object for FBProphet that we have just computed.
    &#34;&#34;&#34;
    transformations_to_test = [*param_config[&#34;model_parameters&#34;][&#34;possible_transformations&#34;].split(&#34;,&#34;)]
    main_accuracy_estimator = param_config[&#34;model_parameters&#34;][&#34;main_accuracy_estimator&#34;]
    models = [*param_config[&#34;model_parameters&#34;][&#34;models&#34;].split(&#34;,&#34;)]

    best_transformations = dict.fromkeys(models, {})
    timeseries_containers = []

    try:
        max_threads = param_config[&#39;max_threads&#39;]
    except KeyError:
        try:
            max_threads = len(os.sched_getaffinity(0))
        except:
            max_threads = 1

    columns = ingested_data.columns

    for col in columns:
        model_results = {}
        timeseries_data = ingested_data[[col]]
        xcorr = total_xcorr[col] if total_xcorr is not None else None

        for model in models:
            this_model_performances = []

            log.info(f&#34;Using model {model}...&#34;)

            for transf in transformations_to_test:
                log.info(f&#34;Computing univariate prediction for {col} using transformation: {transf}...&#34;)
                predictor = model_factory(model, param_config=param_config, transformation=transf)
                _result = predictor.launch_model(timeseries_data.copy(), max_threads=max_threads)

                performances = _result.results
                performances.sort(key=lambda x: getattr(x.testing_performances, main_accuracy_estimator.upper()))
                performances = getattr(performances[0].testing_performances, main_accuracy_estimator.upper())

                this_model_performances.append((_result, performances, transf))

            this_model_performances.sort(key=lambda x: x[1])
            best_tr = this_model_performances[0][2]
            [log.debug(f&#34;Error with {t}: {e}&#34;) for t, e in zip(map(lambda x: x[2], this_model_performances),
                                                               map(lambda x: x[1], this_model_performances))]
            log.info(f&#34;Best transformation for {col} using {model}: {best_tr}&#34;)
            best_transformations[model][col] = best_tr
            model_results[model] = this_model_performances[0][0]

        timeseries_containers.append(
            TimeSeriesContainer(timeseries_data, model_results, xcorr)
        )

    return best_transformations, timeseries_containers</code></pre>
</details>
</dd>
<dt id="timexseries.data_prediction.pipeline.model_factory"><code class="name flex">
<span>def <span class="ident">model_factory</span></span>(<span>model_class: str, param_config: dict, transformation: str = None) ‑> <a title="timexseries.data_prediction.models.predictor.PredictionModel" href="models/predictor.html#timexseries.data_prediction.models.predictor.PredictionModel">PredictionModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Given the name of the model, return the corresponding PredictionModel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model_class</code></strong> :&ensp;<code>str</code></dt>
<dd>Model type, e.g. "fbprophet"</dd>
<dt><strong><code>param_config</code></strong> :&ensp;<code>dict</code></dt>
<dd>TIMEX configuration dictionary, to pass to the just created model.</dd>
<dt><strong><code>transformation</code></strong> :&ensp;<code>str</code>, optional, default <code>None</code></dt>
<dd>Optional <code>transformation</code> parameter to pass to the just created model.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PredictionModel</code></dt>
<dd>Prediction model of the class specified in <code>model_class</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; param_config = {
...    &quot;model_parameters&quot;: {
...        &quot;possible_transformations&quot;: &quot;none,log_modified&quot;,
...        &quot;main_accuracy_estimator&quot;: &quot;mae&quot;,
...        &quot;delta_training_percentage&quot;: 20,
...        &quot;test_values&quot;: 5,
...        &quot;prediction_lags&quot;: 7,
...    },
...}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; model = model_factory(&quot;fbprophet&quot;, param_config, &quot;none&quot;)
&gt;&gt;&gt; print(type(model))
&lt;class 'timexseries.data_prediction.models.prophet_predictor.FBProphetModel'&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_factory(model_class: str, param_config: dict, transformation: str = None) -&gt; PredictionModel:
    &#34;&#34;&#34;
    Given the name of the model, return the corresponding PredictionModel.

    Parameters
    ----------
    model_class : str
        Model type, e.g. &#34;fbprophet&#34;
    param_config : dict
        TIMEX configuration dictionary, to pass to the just created model.
    transformation : str, optional, default None
        Optional `transformation` parameter to pass to the just created model.

    Returns
    -------
    PredictionModel
        Prediction model of the class specified in `model_class`.

    Examples
    --------
    &gt;&gt;&gt; param_config = {
    ...    &#34;model_parameters&#34;: {
    ...        &#34;possible_transformations&#34;: &#34;none,log_modified&#34;,
    ...        &#34;main_accuracy_estimator&#34;: &#34;mae&#34;,
    ...        &#34;delta_training_percentage&#34;: 20,
    ...        &#34;test_values&#34;: 5,
    ...        &#34;prediction_lags&#34;: 7,
    ...    },
    ...}

    &gt;&gt;&gt; model = model_factory(&#34;fbprophet&#34;, param_config, &#34;none&#34;)
    &gt;&gt;&gt; print(type(model))
    &lt;class &#39;timexseries.data_prediction.models.prophet_predictor.FBProphetModel&#39;&gt;
    &#34;&#34;&#34;
    model_class = model_class.lower()
    if model_class == &#34;fbprophet&#34;:
        return FBProphetModel(params=param_config, transformation=transformation)
    if model_class == &#34;lstm&#34;:
        return LSTMModel(param_config, transformation)
    # if model_class == &#34;neuralprophet&#34;:
    #     return NeuralProphetModel(param_config, transformation)
    if model_class == &#34;mockup&#34;:
        return MockUpModel(param_config, transformation)
    if model_class == &#34;exponentialsmoothing&#34;:
        return ExponentialSmoothingModel(param_config, transformation)
    else:
        return ARIMAModel(params=param_config, transformation=transformation)</code></pre>
</details>
</dd>
<dt id="timexseries.data_prediction.pipeline.prepare_extra_regressor"><code class="name flex">
<span>def <span class="ident">prepare_extra_regressor</span></span>(<span>container: <a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a>, model: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>This function receives a <code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> object, which includes the time-series
historical data and the various predictions for the future.</p>
<p>The best prediction for the model 'model' is taken and appended to the original time-series, in order to obtain a
DataFrame with the original time series and the best possible prediction.</p>
<p>The resulting DataFrame is returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>container</code></strong> :&ensp;<code>TimeSeriesContainer</code></dt>
<dd><code><a title="timexseries.timeseries_container.TimeSeriesContainer" href="../timeseries_container.html#timexseries.timeseries_container.TimeSeriesContainer">TimeSeriesContainer</a></code> from which an extra-regressor should be extracted.</dd>
<dt><strong><code>model</code></strong></dt>
<dd>The model from which get the best available prediction.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>DataFrame with the length of the original time-series + prediction lags.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_extra_regressor(container: TimeSeriesContainer, model: str) -&gt; DataFrame:
    &#34;&#34;&#34;
    This function receives a `timexseries.timeseries_container.TimeSeriesContainer` object, which includes the time-series
    historical data and the various predictions for the future.

    The best prediction for the model &#39;model&#39; is taken and appended to the original time-series, in order to obtain a
    DataFrame with the original time series and the best possible prediction.

    The resulting DataFrame is returned.

    Parameters
    ----------
    container : TimeSeriesContainer
        `timexseries.timeseries_container.TimeSeriesContainer` from which an extra-regressor should be extracted.

    model
        The model from which get the best available prediction.

    Returns
    -------
    df : DataFrame
        DataFrame with the length of the original time-series + prediction lags.
    &#34;&#34;&#34;
    name = container.timeseries_data.columns[0]
    best_prediction = container.models[model].best_prediction

    original_ts = container.timeseries_data
    f = best_prediction.loc[:, [&#39;yhat&#39;]]
    f.rename(columns={&#39;yhat&#39;: name}, inplace=True)

    best_entire_forecast = original_ts.combine_first(f)

    return best_entire_forecast</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="timexseries.data_prediction" href="index.html">timexseries.data_prediction</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="timexseries.data_prediction.pipeline.compute_historical_predictions" href="#timexseries.data_prediction.pipeline.compute_historical_predictions">compute_historical_predictions</a></code></li>
<li><code><a title="timexseries.data_prediction.pipeline.create_timeseries_containers" href="#timexseries.data_prediction.pipeline.create_timeseries_containers">create_timeseries_containers</a></code></li>
<li><code><a title="timexseries.data_prediction.pipeline.get_best_multivariate_predictions" href="#timexseries.data_prediction.pipeline.get_best_multivariate_predictions">get_best_multivariate_predictions</a></code></li>
<li><code><a title="timexseries.data_prediction.pipeline.get_best_predictions" href="#timexseries.data_prediction.pipeline.get_best_predictions">get_best_predictions</a></code></li>
<li><code><a title="timexseries.data_prediction.pipeline.get_best_univariate_predictions" href="#timexseries.data_prediction.pipeline.get_best_univariate_predictions">get_best_univariate_predictions</a></code></li>
<li><code><a title="timexseries.data_prediction.pipeline.model_factory" href="#timexseries.data_prediction.pipeline.model_factory">model_factory</a></code></li>
<li><code><a title="timexseries.data_prediction.pipeline.prepare_extra_regressor" href="#timexseries.data_prediction.pipeline.prepare_extra_regressor">prepare_extra_regressor</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>