<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>timexseries.data_prediction.transformation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>timexseries.data_prediction.transformation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from pandas import Series
import numpy as np
from scipy.stats import yeojohnson


class Transformation:
    &#34;&#34;&#34;
    Super-class used to represent various types of data transformation.
    &#34;&#34;&#34;

    def apply(self, data: Series) -&gt; Series:
        &#34;&#34;&#34;
        Apply the transformation on each value in a Pandas Series. Returns the transformed Series, i.e. a Series with
        transformed values.

        Note that it is not guaranteed that the dtype of the returned Series is the same of `data`.

        Parameters
        ----------
        data : Series
            Data to transform.

        Returns
        -------
        Series
            Transformed data.
        &#34;&#34;&#34;
        pass

    def inverse(self, data: Series) -&gt; Series:
        &#34;&#34;&#34;
        Apply the inverse of the transformation on the values of a Pandas Series of transformed values.
        Returns the data re-transformed back to the real world.

        Any class implementing Transformation should make the `inverse` method always return a Series with the same
        shape as the one of `data`. If the function is not invertible (e.g. Log), the returning values should be
        approximated. It is assumed in the rest of TIMEX that `inverse` does not fail.

        Parameters
        ----------
        data : Series
            Data to transform.

        Returns
        -------
        Series
            Transformed data.
        &#34;&#34;&#34;
        pass


class Log(Transformation):
    &#34;&#34;&#34;Class corresponding to a somewhat classic logarithmic feature transformation.

    Notes
    -----
    The actual function computed by this transformation is:

    .. math::
        f(x) = sign(x) * log(|x|)

    if `x` &gt; 1, 0 otherwise.

    Note that this way time-series which contain 0 values will have its values modified, because `inverse` will return
    1 instead of 0 when returning the transformed time-series to the real world.

    The inverse function, indeed, is:

    .. math::
        f^{-1}(x) = sign(x) * e^{abs(x)}

    LogModified should be preferred.
    &#34;&#34;&#34;
    def apply(self, data: Series) -&gt; Series:
        return data.apply(lambda x: np.sign(x) * np.log(abs(x)) if abs(x) &gt; 1 else 0)

    def inverse(self, data: Series) -&gt; Series:
        return data.apply(lambda x: np.sign(x) * np.exp(abs(x)))

    def __str__(self):
        return &#34;Log&#34;


class LogModified(Transformation):
    &#34;&#34;&#34;Class corresponding to the a custom variant of logarithmic feature transformation.
    In particular, this transformation tries to overcome the traditional issues of a logarithmic transformation, i.e.
    the impossibility to work on negative data and the different behaviour on 0 &lt; x &lt; 1.

    Notes
    -----
    The actual function computed by this transformation is:

    .. math::
        f(x) = sign(x) * log(|x| + 1)

    The inverse, instead, is:

    .. math::
        f^{-1}(x) = sign(x) * e^{(abs(x) - sign(x))}
    &#34;&#34;&#34;
    def apply(self, data: Series) -&gt; Series:
        return data.apply(lambda x: np.sign(x) * np.log(abs(x) + 1))

    def inverse(self, data: Series) -&gt; Series:
        return data.apply(lambda x: np.sign(x) * np.exp(abs(x)) - np.sign(x))

    def __str__(self):
        return &#34;modified Log&#34;


class Identity(Transformation):
    &#34;&#34;&#34;Class corresponding to the identity transformation.
    This is useful because the absence of a data pre-processing transformation would be a particular case for functions
    which compute predictions; instead, using this, that case is not special anymore.

    Notes
    -----
    The actual function computed by this transformation is:

    .. math::
        f(x) = x

    The inverse, instead, is:

    .. math::
        f^{-1}(x) = x
    &#34;&#34;&#34;
    def apply(self, data: Series) -&gt; Series:
        return data

    def inverse(self, data: Series) -&gt; Series:
        return data

    def __str__(self):
        return &#34;none&#34;


class YeoJohnson(Transformation):
    &#34;&#34;&#34;Class corresponding to the Yeo-Johnson transformation.

    Notes
    -----
    Introduced in [^1], this transformation tries to make the input data more stable.

    Warnings
    --------
    .. warning:: Yeo-Johnson is basically broken for some series with high values.
                 Follow this issue: https://github.com/scikit-learn/scikit-learn/issues/14959
                 Until this is solved, Yeo-Johnson may not work as expected and create random crashes.

    References
    ----------
    [^1]: Yeo, I. K., &amp; Johnson, R. A. (2000). A new family of power transformations to improve normality or symmetry.
          Biometrika, 87(4), 954-959. https://doi.org/10.1093/biomet/87.4.954
    &#34;&#34;&#34;

    def __init__(self):
        self.lmbda = 0

    def apply(self, data: Series) -&gt; Series:
        ind = data.index
        res, lmbda = yeojohnson(data)
        self.lmbda = lmbda
        return Series(res, index=ind)

    def inverse(self, data: Series) -&gt; Series:
        ind = data.index
        lmbda = self.lmbda
        x_inv = np.zeros_like(data)
        pos = data &gt;= 0

        # when x &gt;= 0
        if abs(lmbda) &lt; np.spacing(1.):
            x_inv[pos] = np.exp(data[pos]) - 1
        else:  # lmbda != 0
            x_inv[pos] = np.power(data[pos] * lmbda + 1, 1 / lmbda) - 1

        # when x &lt; 0
        if abs(lmbda - 2) &gt; np.spacing(1.):
            x_inv[~pos] = 1 - np.power(-(2 - lmbda) * data[~pos] + 1,
                                       1 / (2 - lmbda))
        else:  # lmbda == 2
            x_inv[~pos] = 1 - np.exp(-data[~pos])

        return Series(x_inv, index=ind)

    def __str__(self):
        return f&#34;Yeo-Johnson (lambda: {round(self.lmbda, 3)})&#34;


class Diff(Transformation):
    &#34;&#34;&#34;Class corresponding to the differentiate transformation.
    Basically, each value at time `t` is computed as the difference between the current value and the past one.
    Applying this transformation makes the transformed Series have one less value, because the first one can not be
    computed; the value is saved in order to be able to recompute `inverse`.

    Notes
    -----
    Let `X` be the time-series and `X(t)` the value of the time-series at time `t`. This transformation changes X in Y,
    where:

    .. math::
        Y(t) = X(t) - X(t-1)
    &#34;&#34;&#34;
    def __init__(self):
        self.first_value = 0

    def apply(self, data: Series) -&gt; Series:
        self.first_value = data[0]
        return data.diff()[1:]

    def inverse(self, data: Series) -&gt; Series:
        return Series(np.r_[self.first_value, data].cumsum())

    def __str__(self):
        return &#34;differentiate (1)&#34;


def transformation_factory(tr_class: str) -&gt; Transformation:
    &#34;&#34;&#34;
    Given the type of the transformation, encoded as string, return the Transformation object.

    Parameters
    ----------
    tr_class : str
        Transformation type.

    Returns
    -------
    Transformation
        Transformation object.

    Examples
    --------
    Create a Pandas Series and apply the logarithmic transformation:

    &gt;&gt;&gt; x = Series([2, 3, 4, 5])
    &gt;&gt;&gt; tr = transformation_factory(&#34;log&#34;)
    &gt;&gt;&gt; tr_x = tr.apply(x)
    &gt;&gt;&gt; tr_x
    0    0.693147
    1    1.098612
    2    1.386294
    3    1.609438
    dtype: float64

    Now, let&#39;s compute the inverse transformation which should return the data to the real world:

    &gt;&gt;&gt; inv_tr_x = tr.inverse(tr_x)
    &gt;&gt;&gt; inv_tr_x
    0    2.0
    1    3.0
    2    4.0
    3    5.0
    dtype: float64
    &#34;&#34;&#34;
    if tr_class == &#34;log&#34;:
        return Log()
    elif tr_class == &#34;log_modified&#34;:
        return LogModified()
    elif tr_class == &#34;none&#34;:
        return Identity()
    elif tr_class == &#34;diff&#34;:
        return Diff()
    elif tr_class == &#34;yeo_johnson&#34;:
        return YeoJohnson()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="timexseries.data_prediction.transformation.transformation_factory"><code class="name flex">
<span>def <span class="ident">transformation_factory</span></span>(<span>tr_class: str) ‑> <a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></span>
</code></dt>
<dd>
<div class="desc"><p>Given the type of the transformation, encoded as string, return the Transformation object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tr_class</code></strong> :&ensp;<code>str</code></dt>
<dd>Transformation type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></code></dt>
<dd>Transformation object.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Create a Pandas Series and apply the logarithmic transformation:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; x = Series([2, 3, 4, 5])
&gt;&gt;&gt; tr = transformation_factory(&quot;log&quot;)
&gt;&gt;&gt; tr_x = tr.apply(x)
&gt;&gt;&gt; tr_x
0    0.693147
1    1.098612
2    1.386294
3    1.609438
dtype: float64
</code></pre>
<p>Now, let's compute the inverse transformation which should return the data to the real world:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; inv_tr_x = tr.inverse(tr_x)
&gt;&gt;&gt; inv_tr_x
0    2.0
1    3.0
2    4.0
3    5.0
dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transformation_factory(tr_class: str) -&gt; Transformation:
    &#34;&#34;&#34;
    Given the type of the transformation, encoded as string, return the Transformation object.

    Parameters
    ----------
    tr_class : str
        Transformation type.

    Returns
    -------
    Transformation
        Transformation object.

    Examples
    --------
    Create a Pandas Series and apply the logarithmic transformation:

    &gt;&gt;&gt; x = Series([2, 3, 4, 5])
    &gt;&gt;&gt; tr = transformation_factory(&#34;log&#34;)
    &gt;&gt;&gt; tr_x = tr.apply(x)
    &gt;&gt;&gt; tr_x
    0    0.693147
    1    1.098612
    2    1.386294
    3    1.609438
    dtype: float64

    Now, let&#39;s compute the inverse transformation which should return the data to the real world:

    &gt;&gt;&gt; inv_tr_x = tr.inverse(tr_x)
    &gt;&gt;&gt; inv_tr_x
    0    2.0
    1    3.0
    2    4.0
    3    5.0
    dtype: float64
    &#34;&#34;&#34;
    if tr_class == &#34;log&#34;:
        return Log()
    elif tr_class == &#34;log_modified&#34;:
        return LogModified()
    elif tr_class == &#34;none&#34;:
        return Identity()
    elif tr_class == &#34;diff&#34;:
        return Diff()
    elif tr_class == &#34;yeo_johnson&#34;:
        return YeoJohnson()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="timexseries.data_prediction.transformation.Diff"><code class="flex name class">
<span>class <span class="ident">Diff</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class corresponding to the differentiate transformation.
Basically, each value at time <code>t</code> is computed as the difference between the current value and the past one.
Applying this transformation makes the transformed Series have one less value, because the first one can not be
computed; the value is saved in order to be able to recompute <code>inverse</code>.</p>
<h2 id="notes">Notes</h2>
<p>Let <code>X</code> be the time-series and <code>X(t)</code> the value of the time-series at time <code>t</code>. This transformation changes X in Y,
where:</p>
<p><span><span class="MathJax_Preview"> Y(t) = X(t) - X(t-1) </span><script type="math/tex; mode=display"> Y(t) = X(t) - X(t-1) </script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Diff(Transformation):
    &#34;&#34;&#34;Class corresponding to the differentiate transformation.
    Basically, each value at time `t` is computed as the difference between the current value and the past one.
    Applying this transformation makes the transformed Series have one less value, because the first one can not be
    computed; the value is saved in order to be able to recompute `inverse`.

    Notes
    -----
    Let `X` be the time-series and `X(t)` the value of the time-series at time `t`. This transformation changes X in Y,
    where:

    .. math::
        Y(t) = X(t) - X(t-1)
    &#34;&#34;&#34;
    def __init__(self):
        self.first_value = 0

    def apply(self, data: Series) -&gt; Series:
        self.first_value = data[0]
        return data.diff()[1:]

    def inverse(self, data: Series) -&gt; Series:
        return Series(np.r_[self.first_value, data].cumsum())

    def __str__(self):
        return &#34;differentiate (1)&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></b></code>:
<ul class="hlist">
<li><code><a title="timexseries.data_prediction.transformation.Transformation.apply" href="#timexseries.data_prediction.transformation.Transformation.apply">apply</a></code></li>
<li><code><a title="timexseries.data_prediction.transformation.Transformation.inverse" href="#timexseries.data_prediction.transformation.Transformation.inverse">inverse</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="timexseries.data_prediction.transformation.Identity"><code class="flex name class">
<span>class <span class="ident">Identity</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class corresponding to the identity transformation.
This is useful because the absence of a data pre-processing transformation would be a particular case for functions
which compute predictions; instead, using this, that case is not special anymore.</p>
<h2 id="notes">Notes</h2>
<p>The actual function computed by this transformation is:</p>
<p><span><span class="MathJax_Preview"> f(x) = x </span><script type="math/tex; mode=display"> f(x) = x </script></span>
The inverse, instead, is:</p>
<p><span><span class="MathJax_Preview"> f^{-1}(x) = x </span><script type="math/tex; mode=display"> f^{-1}(x) = x </script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Identity(Transformation):
    &#34;&#34;&#34;Class corresponding to the identity transformation.
    This is useful because the absence of a data pre-processing transformation would be a particular case for functions
    which compute predictions; instead, using this, that case is not special anymore.

    Notes
    -----
    The actual function computed by this transformation is:

    .. math::
        f(x) = x

    The inverse, instead, is:

    .. math::
        f^{-1}(x) = x
    &#34;&#34;&#34;
    def apply(self, data: Series) -&gt; Series:
        return data

    def inverse(self, data: Series) -&gt; Series:
        return data

    def __str__(self):
        return &#34;none&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></b></code>:
<ul class="hlist">
<li><code><a title="timexseries.data_prediction.transformation.Transformation.apply" href="#timexseries.data_prediction.transformation.Transformation.apply">apply</a></code></li>
<li><code><a title="timexseries.data_prediction.transformation.Transformation.inverse" href="#timexseries.data_prediction.transformation.Transformation.inverse">inverse</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="timexseries.data_prediction.transformation.Log"><code class="flex name class">
<span>class <span class="ident">Log</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class corresponding to a somewhat classic logarithmic feature transformation.</p>
<h2 id="notes">Notes</h2>
<p>The actual function computed by this transformation is:</p>
<p><span><span class="MathJax_Preview"> f(x) = sign(x) * log(|x|) </span><script type="math/tex; mode=display"> f(x) = sign(x) * log(|x|) </script></span>
if <code>x</code> &gt; 1, 0 otherwise.</p>
<p>Note that this way time-series which contain 0 values will have its values modified, because <code>inverse</code> will return
1 instead of 0 when returning the transformed time-series to the real world.</p>
<p>The inverse function, indeed, is:</p>
<p><span><span class="MathJax_Preview"> f^{-1}(x) = sign(x) * e^{abs(x)} </span><script type="math/tex; mode=display"> f^{-1}(x) = sign(x) * e^{abs(x)} </script></span>
LogModified should be preferred.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Log(Transformation):
    &#34;&#34;&#34;Class corresponding to a somewhat classic logarithmic feature transformation.

    Notes
    -----
    The actual function computed by this transformation is:

    .. math::
        f(x) = sign(x) * log(|x|)

    if `x` &gt; 1, 0 otherwise.

    Note that this way time-series which contain 0 values will have its values modified, because `inverse` will return
    1 instead of 0 when returning the transformed time-series to the real world.

    The inverse function, indeed, is:

    .. math::
        f^{-1}(x) = sign(x) * e^{abs(x)}

    LogModified should be preferred.
    &#34;&#34;&#34;
    def apply(self, data: Series) -&gt; Series:
        return data.apply(lambda x: np.sign(x) * np.log(abs(x)) if abs(x) &gt; 1 else 0)

    def inverse(self, data: Series) -&gt; Series:
        return data.apply(lambda x: np.sign(x) * np.exp(abs(x)))

    def __str__(self):
        return &#34;Log&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></b></code>:
<ul class="hlist">
<li><code><a title="timexseries.data_prediction.transformation.Transformation.apply" href="#timexseries.data_prediction.transformation.Transformation.apply">apply</a></code></li>
<li><code><a title="timexseries.data_prediction.transformation.Transformation.inverse" href="#timexseries.data_prediction.transformation.Transformation.inverse">inverse</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="timexseries.data_prediction.transformation.LogModified"><code class="flex name class">
<span>class <span class="ident">LogModified</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class corresponding to the a custom variant of logarithmic feature transformation.
In particular, this transformation tries to overcome the traditional issues of a logarithmic transformation, i.e.
the impossibility to work on negative data and the different behaviour on 0 &lt; x &lt; 1.</p>
<h2 id="notes">Notes</h2>
<p>The actual function computed by this transformation is:</p>
<p><span><span class="MathJax_Preview"> f(x) = sign(x) * log(|x| + 1) </span><script type="math/tex; mode=display"> f(x) = sign(x) * log(|x| + 1) </script></span>
The inverse, instead, is:</p>
<p><span><span class="MathJax_Preview"> f^{-1}(x) = sign(x) * e^{(abs(x) - sign(x))} </span><script type="math/tex; mode=display"> f^{-1}(x) = sign(x) * e^{(abs(x) - sign(x))} </script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LogModified(Transformation):
    &#34;&#34;&#34;Class corresponding to the a custom variant of logarithmic feature transformation.
    In particular, this transformation tries to overcome the traditional issues of a logarithmic transformation, i.e.
    the impossibility to work on negative data and the different behaviour on 0 &lt; x &lt; 1.

    Notes
    -----
    The actual function computed by this transformation is:

    .. math::
        f(x) = sign(x) * log(|x| + 1)

    The inverse, instead, is:

    .. math::
        f^{-1}(x) = sign(x) * e^{(abs(x) - sign(x))}
    &#34;&#34;&#34;
    def apply(self, data: Series) -&gt; Series:
        return data.apply(lambda x: np.sign(x) * np.log(abs(x) + 1))

    def inverse(self, data: Series) -&gt; Series:
        return data.apply(lambda x: np.sign(x) * np.exp(abs(x)) - np.sign(x))

    def __str__(self):
        return &#34;modified Log&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></b></code>:
<ul class="hlist">
<li><code><a title="timexseries.data_prediction.transformation.Transformation.apply" href="#timexseries.data_prediction.transformation.Transformation.apply">apply</a></code></li>
<li><code><a title="timexseries.data_prediction.transformation.Transformation.inverse" href="#timexseries.data_prediction.transformation.Transformation.inverse">inverse</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="timexseries.data_prediction.transformation.Transformation"><code class="flex name class">
<span>class <span class="ident">Transformation</span></span>
</code></dt>
<dd>
<div class="desc"><p>Super-class used to represent various types of data transformation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transformation:
    &#34;&#34;&#34;
    Super-class used to represent various types of data transformation.
    &#34;&#34;&#34;

    def apply(self, data: Series) -&gt; Series:
        &#34;&#34;&#34;
        Apply the transformation on each value in a Pandas Series. Returns the transformed Series, i.e. a Series with
        transformed values.

        Note that it is not guaranteed that the dtype of the returned Series is the same of `data`.

        Parameters
        ----------
        data : Series
            Data to transform.

        Returns
        -------
        Series
            Transformed data.
        &#34;&#34;&#34;
        pass

    def inverse(self, data: Series) -&gt; Series:
        &#34;&#34;&#34;
        Apply the inverse of the transformation on the values of a Pandas Series of transformed values.
        Returns the data re-transformed back to the real world.

        Any class implementing Transformation should make the `inverse` method always return a Series with the same
        shape as the one of `data`. If the function is not invertible (e.g. Log), the returning values should be
        approximated. It is assumed in the rest of TIMEX that `inverse` does not fail.

        Parameters
        ----------
        data : Series
            Data to transform.

        Returns
        -------
        Series
            Transformed data.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="timexseries.data_prediction.transformation.Diff" href="#timexseries.data_prediction.transformation.Diff">Diff</a></li>
<li><a title="timexseries.data_prediction.transformation.Identity" href="#timexseries.data_prediction.transformation.Identity">Identity</a></li>
<li><a title="timexseries.data_prediction.transformation.Log" href="#timexseries.data_prediction.transformation.Log">Log</a></li>
<li><a title="timexseries.data_prediction.transformation.LogModified" href="#timexseries.data_prediction.transformation.LogModified">LogModified</a></li>
<li><a title="timexseries.data_prediction.transformation.YeoJohnson" href="#timexseries.data_prediction.transformation.YeoJohnson">YeoJohnson</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="timexseries.data_prediction.transformation.Transformation.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, data: pandas.core.series.Series) ‑> pandas.core.series.Series</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the transformation on each value in a Pandas Series. Returns the transformed Series, i.e. a Series with
transformed values.</p>
<p>Note that it is not guaranteed that the dtype of the returned Series is the same of <code>data</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Series</code></dt>
<dd>Data to transform.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Series</code></dt>
<dd>Transformed data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, data: Series) -&gt; Series:
    &#34;&#34;&#34;
    Apply the transformation on each value in a Pandas Series. Returns the transformed Series, i.e. a Series with
    transformed values.

    Note that it is not guaranteed that the dtype of the returned Series is the same of `data`.

    Parameters
    ----------
    data : Series
        Data to transform.

    Returns
    -------
    Series
        Transformed data.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="timexseries.data_prediction.transformation.Transformation.inverse"><code class="name flex">
<span>def <span class="ident">inverse</span></span>(<span>self, data: pandas.core.series.Series) ‑> pandas.core.series.Series</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the inverse of the transformation on the values of a Pandas Series of transformed values.
Returns the data re-transformed back to the real world.</p>
<p>Any class implementing Transformation should make the <code>inverse</code> method always return a Series with the same
shape as the one of <code>data</code>. If the function is not invertible (e.g. Log), the returning values should be
approximated. It is assumed in the rest of TIMEX that <code>inverse</code> does not fail.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Series</code></dt>
<dd>Data to transform.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Series</code></dt>
<dd>Transformed data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse(self, data: Series) -&gt; Series:
    &#34;&#34;&#34;
    Apply the inverse of the transformation on the values of a Pandas Series of transformed values.
    Returns the data re-transformed back to the real world.

    Any class implementing Transformation should make the `inverse` method always return a Series with the same
    shape as the one of `data`. If the function is not invertible (e.g. Log), the returning values should be
    approximated. It is assumed in the rest of TIMEX that `inverse` does not fail.

    Parameters
    ----------
    data : Series
        Data to transform.

    Returns
    -------
    Series
        Transformed data.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="timexseries.data_prediction.transformation.YeoJohnson"><code class="flex name class">
<span>class <span class="ident">YeoJohnson</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class corresponding to the Yeo-Johnson transformation.</p>
<h2 id="notes">Notes</h2>
<p>Introduced in <sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>, this transformation tries to make the input data more stable.</p>
<h2 id="warnings">Warnings</h2>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;Yeo-Johnson is basically broken for some series with high values.</p>
<p>Follow this issue: <a href="https://github.com/scikit-learn/scikit-learn/issues/14959">https://github.com/scikit-learn/scikit-learn/issues/14959</a>
Until this is solved, Yeo-Johnson may not work as expected and create random crashes.</p>
</div>
<h2 id="references">References</h2>
<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>Yeo, I. K., &amp; Johnson, R. A. (2000). A new family of power transformations to improve normality or symmetry.
Biometrika, 87(4), 954-959. <a href="https://doi.org/10.1093/biomet/87.4.954">https://doi.org/10.1093/biomet/87.4.954</a>&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class YeoJohnson(Transformation):
    &#34;&#34;&#34;Class corresponding to the Yeo-Johnson transformation.

    Notes
    -----
    Introduced in [^1], this transformation tries to make the input data more stable.

    Warnings
    --------
    .. warning:: Yeo-Johnson is basically broken for some series with high values.
                 Follow this issue: https://github.com/scikit-learn/scikit-learn/issues/14959
                 Until this is solved, Yeo-Johnson may not work as expected and create random crashes.

    References
    ----------
    [^1]: Yeo, I. K., &amp; Johnson, R. A. (2000). A new family of power transformations to improve normality or symmetry.
          Biometrika, 87(4), 954-959. https://doi.org/10.1093/biomet/87.4.954
    &#34;&#34;&#34;

    def __init__(self):
        self.lmbda = 0

    def apply(self, data: Series) -&gt; Series:
        ind = data.index
        res, lmbda = yeojohnson(data)
        self.lmbda = lmbda
        return Series(res, index=ind)

    def inverse(self, data: Series) -&gt; Series:
        ind = data.index
        lmbda = self.lmbda
        x_inv = np.zeros_like(data)
        pos = data &gt;= 0

        # when x &gt;= 0
        if abs(lmbda) &lt; np.spacing(1.):
            x_inv[pos] = np.exp(data[pos]) - 1
        else:  # lmbda != 0
            x_inv[pos] = np.power(data[pos] * lmbda + 1, 1 / lmbda) - 1

        # when x &lt; 0
        if abs(lmbda - 2) &gt; np.spacing(1.):
            x_inv[~pos] = 1 - np.power(-(2 - lmbda) * data[~pos] + 1,
                                       1 / (2 - lmbda))
        else:  # lmbda == 2
            x_inv[~pos] = 1 - np.exp(-data[~pos])

        return Series(x_inv, index=ind)

    def __str__(self):
        return f&#34;Yeo-Johnson (lambda: {round(self.lmbda, 3)})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></b></code>:
<ul class="hlist">
<li><code><a title="timexseries.data_prediction.transformation.Transformation.apply" href="#timexseries.data_prediction.transformation.Transformation.apply">apply</a></code></li>
<li><code><a title="timexseries.data_prediction.transformation.Transformation.inverse" href="#timexseries.data_prediction.transformation.Transformation.inverse">inverse</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="timexseries.data_prediction" href="index.html">timexseries.data_prediction</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="timexseries.data_prediction.transformation.transformation_factory" href="#timexseries.data_prediction.transformation.transformation_factory">transformation_factory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="timexseries.data_prediction.transformation.Diff" href="#timexseries.data_prediction.transformation.Diff">Diff</a></code></h4>
</li>
<li>
<h4><code><a title="timexseries.data_prediction.transformation.Identity" href="#timexseries.data_prediction.transformation.Identity">Identity</a></code></h4>
</li>
<li>
<h4><code><a title="timexseries.data_prediction.transformation.Log" href="#timexseries.data_prediction.transformation.Log">Log</a></code></h4>
</li>
<li>
<h4><code><a title="timexseries.data_prediction.transformation.LogModified" href="#timexseries.data_prediction.transformation.LogModified">LogModified</a></code></h4>
</li>
<li>
<h4><code><a title="timexseries.data_prediction.transformation.Transformation" href="#timexseries.data_prediction.transformation.Transformation">Transformation</a></code></h4>
<ul class="">
<li><code><a title="timexseries.data_prediction.transformation.Transformation.apply" href="#timexseries.data_prediction.transformation.Transformation.apply">apply</a></code></li>
<li><code><a title="timexseries.data_prediction.transformation.Transformation.inverse" href="#timexseries.data_prediction.transformation.Transformation.inverse">inverse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="timexseries.data_prediction.transformation.YeoJohnson" href="#timexseries.data_prediction.transformation.YeoJohnson">YeoJohnson</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>